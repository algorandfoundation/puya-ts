subroutine testConstructor(a: uint64, b: bool, c: bytes): void
{
  0
  reinterpret_cast<biguint>(itob(True))
  reinterpret_cast<biguint>(itob(False))
  0
  1
  0
  1
  13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084095
  1231232134123123
  reinterpret_cast<biguint>(itob(a))
  reinterpret_cast<biguint>(itob(a * a))
  reinterpret_cast<biguint>(itob(b))
  reinterpret_cast<biguint>(c)
}
subroutine testOps(smaller: biguint, larger: biguint): void
{
  assert(smaller < larger)
  assert(smaller <= smaller)
  assert(larger > smaller)
  assert(larger >= larger)
  assert(smaller == smaller)
  assert(smaller == reinterpret_cast<biguint>(concat(bzero(4), reinterpret_cast<bytes>(smaller))), comment=Leading zeros should be ignored in equality)
}
contract DemoContract
{
  approvalProgram(): bool
  {
    if (!Boolean(txn<ApplicationID>())) {
      this.constructor()
    }
    tests/approvals/biguint-expressions.algo.ts::testConstructor(1, False, itob(4))
    tests/approvals/biguint-expressions.algo.ts::testOps(500, 1000)
    return True
  }
  
  clearProgram(): bool
  {
    return True
  }
  
  constructor(): void
  {
    void
  }
  
  Contract::constructor(): void
  {
    this.constructor()
  }
  
}