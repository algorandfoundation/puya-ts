subroutine testPartialDestructure(arg: tuple[uint64, uint64, uint64]): void
{
  <tuple>[x, _, _₁]: readonlytuple[uint64, uint64, uint64] = arg
  <tuple>[<tuple>[_₂, y, _₃]]: readonlytuple[readonlytuple[uint64, uint64, uint64]] = <tuple>[arg]
}
subroutine test(): void
{
  <tuple>[a, b, c, d]: readonlytuple[uint64, bytes, bool, biguint] = tests/approvals/object-destructuring.algo.ts::produceItems()
  <tuple>[_, _₁, _₂, e]: readonlytuple[uint64, bytes, bool, biguint] = tests/approvals/object-destructuring.algo.ts::produceItems()
  f: tuple[uint64, bytes, bool, biguint] = (<tuple>[g, _₃, _₄, i] = tests/approvals/object-destructuring.algo.ts::produceItems())
  tests/approvals/object-destructuring.algo.ts::receivePartial(<tuple>[(#0 = tests/approvals/object-destructuring.algo.ts::produceItems()).0, #0.3])
}
subroutine produceItems(): tuple[uint64, bytes, bool, biguint]
{
  return <tuple>[1, "", False, 999]
}
subroutine receivePartial(x: tuple[uint64, biguint]): void
{
}
subroutine testLiteralToLiteral(): void
{
  a: uint64 = 4
  b: uint64 = 1
  <tuple>[e, f]: readonlytuple[uint64, uint64] = (<tuple>[c, d] = <tuple>[a, b])
}
subroutine testNumericResolution(): void
{
  x: tuple[uint64] = (y = <tuple>[434])
}
subroutine test2(args: tuple[bool, bool, readonlytuple[string, string]]): void
{
  <tuple>[a, <tuple>[x, y, _], b]: readonlytuple[bool, readonlytuple[bool, bool, readonlytuple[string, string]], bool] = <tuple>[True, args, False]
  args2: tuple[bool, bool, readonlytuple[string, string]] = <tuple>[True, True, args.2]
}