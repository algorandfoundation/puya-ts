subroutine testBox(box: box_key, value: string): void
{
  var box.value: string = value
  var Box["A"].value: string = value
  assert(box.value == Box["A"].value)
  assert(STATE_EXISTS(box.value) and STATE_EXISTS(Box["A"].value))
  STATE_DEL(box.value)
  STATE_DEL(Box["A"].value)
  assert(!STATE_EXISTS(box.value) and !STATE_EXISTS(Box["A"].value))
  var defaultVal: string = "O"
  assert(STATE_GET(Box["A"].value, default=defaultVal) == STATE_GET(box.value, default=defaultVal))
  var <tuple>[_, e]: readonlytuple[string, bool] = STATE_GET_EX(box.value)
  assert(!e)
  var box.value: string = value
  var <tuple>[_‚ÇÅ, e]: readonlytuple[string, bool] = STATE_GET_EX(box.value)
  assert(e)
}
subroutine testBoxMap(box: box_key, key: string, value: bytes): void
{
  var concat(box, reinterpret_cast<bytes>(key)).value: bytes = value
  var concat("", reinterpret_cast<bytes>(key)).value: bytes = value
  assert(concat(box, reinterpret_cast<bytes>(key)).value == concat("", reinterpret_cast<bytes>(key)).value)
  STATE_DEL(concat(box, reinterpret_cast<bytes>(key)).value)
  assert(STATE_GET(concat(box, reinterpret_cast<bytes>("" + key + "x")).value, default="b") == STATE_GET(concat("", reinterpret_cast<bytes>("" + key + "x")).value, default="b"))
}
subroutine testBoxRef(box: box_key): void
{
  var someBytes: bytes = 0x0f0f0f0f
  box_put(box.value, someBytes)
  box_put(Box["abc"].value, someBytes)
  box_splice(box.value, 1, 2, 0x00)
  box_splice(Box["abc"].value, 1, 2, 0x00)
  assert(box.value == 0x0f000f0f)
}