subroutine testBox(box: box_key, value: string): void
{
  Box[box].value: string = value
  Box["A"].value: string = value
  assert(reinterpret_cast<bytes>(box) == "one")
  assert("A" == "A")
  assert(Box[box].value == Box["A"].value)
  assert(STATE_EXISTS(Box[box].value) and STATE_EXISTS(Box["A"].value))
  assert(Boolean(checked_maybe(box_len(box), comment=Box must have value)))
  assert(STATE_DELETE(Box[box].value), comment=delete failed)
  isBoxADeleted: bool = STATE_DELETE(Box["A"].value)
  assert(isBoxADeleted, comment=delete failed)
  assert(!STATE_EXISTS(Box[box].value) and !STATE_EXISTS(Box["A"].value))
  assert(STATE_GET(Box["A"].value, default="O") == STATE_GET(Box[box].value, default="O"))
  <tuple>[_, e]: readonlytuple[string, bool] = STATE_GET_EX(Box[box].value)
  assert(!e)
  Box[box].value: string = value
  <tuple>[_₁, e]: readonlytuple[string, bool] = STATE_GET_EX(Box[box].value)
  assert(e)
}
subroutine testBoxMap(box: box_key, key: string, value: bytes): void
{
  Box[concat(box, reinterpret_cast<bytes>(key))].value: bytes = value
  Box[concat("", reinterpret_cast<bytes>(key))].value: bytes = value
  boxMapItem: box_key = concat("", reinterpret_cast<bytes>(key))
  assert(STATE_EXISTS(Box[boxMapItem].value))
  assert(reinterpret_cast<bytes>(box) == "two")
  assert("" == "")
  assert(Boolean(checked_maybe(box_len(concat(box, reinterpret_cast<bytes>(key))), comment=Box must have value)))
  assert(STATE_GET_EX(Box[concat(box, reinterpret_cast<bytes>(key))].value).1)
  assert(Box[concat(box, reinterpret_cast<bytes>(key))].value == Box[concat("", reinterpret_cast<bytes>(key))].value)
  isBoxDeleted: bool = STATE_DELETE(Box[concat(box, reinterpret_cast<bytes>(key))].value)
  assert(isBoxDeleted, comment=delete failed)
  assert(STATE_GET(Box[concat(box, reinterpret_cast<bytes>("" + key + "x"))].value, default="b") == STATE_GET(Box[concat("", reinterpret_cast<bytes>("" + key + "x"))].value, default="b"))
}
subroutine testBoxRef(box: box_key, length: uint64): void
{
  assert(reinterpret_cast<bytes>(box) == "three")
  assert("abc" == "abc")
  if (!STATE_EXISTS(Box["abc"].value)) {
    box_create("abc", 1000)
  } else {
    if (checked_maybe(box_len("abc"), comment=Box must have value) != length) {
      box_resize("abc", length)
    }
  }
  if (STATE_EXISTS(Box[box].value)) {
    box_resize(box, 4)
  } else {
    box_create(box, 4)
  }
  box_put(box, 0xffffffff)
  assert(STATE_GET(Box[box].value, default=0x) == 0xffffffff)
  maybeBox: readonlytuple[bytes, bool] = STATE_GET_EX(Box[box].value)
  assert(maybeBox.1)
  assert(Box[box].value == 0xffffffff)
  box_splice(box, 1, 1, 0x00)
  assert(Box[box].value == 0xff00ffff)
  x: bool = STATE_DELETE(Box[box].value)
  assert(x, comment=delete failed)
  assert(!STATE_EXISTS(Box[box].value))
}
contract BoxContract
{
  boxes {
    ["one"]: string
    ["two"]: string => bytes
    ["three"]: bytes
  }
  approvalProgram(): bool
  {
    if (reinterpret_cast<uint64>(txn<ApplicationID>()) != 0) {
      tests/approvals/box-proxies.algo.ts::testBox("one", "aaaaaargh")
      tests/approvals/box-proxies.algo.ts::testBoxMap("two", "what?", itob(256456))
      tests/approvals/box-proxies.algo.ts::testBoxRef("three", 99)
    }
    return True
  }
  
  clearProgram(): bool
  {
    return True
  }
  
}
contract BoxNotExist
{
  approvalProgram(): bool
  {
    if (reinterpret_cast<uint64>(txn<ApplicationID>()) != 0) {
      if ((#0 = reinterpret_cast<string>(txnas<ApplicationArgs>(0))) == "box") {
        #switch₁ᶜ₀:
        return Box["abc"].value
      }
      if (#0 == "boxmap") {
        #switch₁ᶜ₁:
        return Box[concat("a", "bc")].value
      }
      if (#0 == "createbox") {
        #switch₁ᶜ₂:
        Box["abc"].value: bool = True
        return True
      }
    }
    return True
  }
  
  clearProgram(): bool
  {
    return True
  }
  
}
contract BoxCreate
{
  boxes {
    ["bool"]: bool
    ["arc4b"]: arc4.bool
    ["a"]: string
    ["b"]: uint64
    ["c"]: arc4.static_array<arc4.uint32>
    ["d"]: arc4.dynamic_array<arc4.uint8>
    ["e"]: arc4.tuple<uint8,uint8,bool,bool>
  }
  approvalProgram(): bool
  {
    return arc4Router()
  }
  
  clearProgram(): bool
  {
    return True
  }
  
  createBoxes(): void
  {
    box_create("a", 10)
    assert(checked_maybe(box_len("a"), comment=Box must have value) == 10)
    box_create("b", 8)
    assert(checked_maybe(box_len("b"), comment=Box must have value) == 8)
    box_create("c", 40)
    assert(checked_maybe(box_len("c"), comment=Box must have value) == 40)
    box_create("d", 2)
    assert(checked_maybe(box_len("d"), comment=Box must have value) == 2)
    box_create("e", 3)
    assert(checked_maybe(box_len("e"), comment=Box must have value) == 3)
    box_create("bool", 8)
    assert(checked_maybe(box_len("bool"), comment=Box must have value) == 8)
    box_create("arc4b", 1)
    assert(checked_maybe(box_len("arc4b"), comment=Box must have value) == 1)
  }
  
  __algots__.defaultCreate(): void
  {
  }
  
}
contract BoxMapTest
{
  boxes {
    [""]: account => string
  }
  approvalProgram(): bool
  {
    return arc4Router()
  }
  
  clearProgram(): bool
  {
    return True
  }
  
  __algots__.defaultCreate(): void
  {
  }
  
}
contract TupleBox
{
  boxes {
    ["t1"]: readonlytuple[string, bytes, bool]
    ["t2"]: object{ a: string, b: bytes, c: bool }
    ["tm1"]: string => readonlytuple[string, bytes, bool]
    ["tm2"]: string => object{ a: string, b: bytes, c: bool }
  }
  approvalProgram(): bool
  {
    return arc4Router()
  }
  
  clearProgram(): bool
  {
    return True
  }
  
  testBox(): void
  {
    box_create("t1", 10)
    box_create("t2", 20)
    assert(checked_maybe(box_len("t1"), comment=Box must have value) == 10)
    assert(checked_maybe(box_len("t2"), comment=Box must have value) == 20)
    assert(STATE_EXISTS(Box["t1"].value))
    assert(STATE_EXISTS(Box["t2"].value))
    Box["t1"].value: readonlytuple[string, bytes, bool] = <tuple>["hello", "world", True]
    assert(Box["t1"].value.0 == "hello")
    assert(Box["t1"].value.1 == "world")
    assert(Box["t1"].value.2)
    Box["t2"].value: object{ a: string, b: bytes, c: bool } = { a: "hello", b: "world", c: True }
    assert(Box["t2"].value.a == "hello")
    assert(Box["t2"].value.b == "world")
    assert(Box["t2"].value.c)
    STATE_DELETE(Box["t1"].value)
    assert(!STATE_EXISTS(Box["t1"].value))
    STATE_DELETE(Box["t2"].value)
    assert(!STATE_EXISTS(Box["t2"].value))
  }
  
  testBoxMap(): void
  {
    assert(!STATE_EXISTS(Box[concat("tm1", "a")].value))
    assert(!STATE_EXISTS(Box[concat("tm2", "a")].value))
    Box[concat("tm1", "a")].value: readonlytuple[string, bytes, bool] = <tuple>["hello", "world", True]
    Box[concat("tm2", "a")].value: object{ a: string, b: bytes, c: bool } = { a: "hello", b: "world", c: True }
    assert(STATE_EXISTS(Box[concat("tm1", "a")].value))
    assert(Box[concat("tm1", "a")].value.0 == "hello")
    assert(Box[concat("tm1", "a")].value.1 == "world")
    assert(Box[concat("tm1", "a")].value.2)
    assert(STATE_EXISTS(Box[concat("tm2", "a")].value))
    assert(Box[concat("tm2", "a")].value.a == "hello")
    assert(Box[concat("tm2", "a")].value.b == "world")
    assert(Box[concat("tm2", "a")].value.c)
    Box[concat("tm1", "b")].value: readonlytuple[string, bytes, bool] = <tuple>["abc", "def", False]
    assert(STATE_EXISTS(Box[concat("tm1", "b")].value))
    Box[concat("tm2", "b")].value: object{ a: string, b: bytes, c: bool } = { a: "abc", b: "def", c: False }
    assert(STATE_EXISTS(Box[concat("tm2", "b")].value))
    STATE_DELETE(Box[concat("tm1", "a")].value)
    assert(!STATE_EXISTS(Box[concat("tm1", "a")].value))
    STATE_DELETE(Box[concat("tm2", "a")].value)
    assert(!STATE_EXISTS(Box[concat("tm2", "a")].value))
  }
  
  __algots__.defaultCreate(): void
  {
  }
  
}