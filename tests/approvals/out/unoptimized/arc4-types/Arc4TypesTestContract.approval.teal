#pragma version 11
#pragma typetrack false

// tests/approvals/arc4-types.algo.ts::Arc4TypesTestContract.approvalProgram() -> uint64:
main:
    intcblock 0 8 2 1 18446744073709551615
    bytecblock 0x00 0x "Hello" 0x0000 base32(AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) 0x00000000000000000000000000000001 0xff 0x000568656c6c6f 0x000620776f726c64 0xaabbccddee 0x2a 0xffffffffffffffff 0x000000000000000000000000000000000000000000000000ffffffffffffffff 0x068101 0x000004dc 0x000400000000 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff 0x00000000
    b main_block@0

main_block@0:
    // tests/approvals/arc4-types.algo.ts:192
    // ensureBudget(1400)
    pushint 1400
    intc_0 // 0
    callsub ensure_budget
    // tests/approvals/arc4-types.algo.ts:194
    // testStr()
    callsub testStr
    // tests/approvals/arc4-types.algo.ts:195
    // testUintN(1, 2n, new Uint<256>(4))
    intc_3 // 1
    pushbytes 0x02
    pushbytes 0x0000000000000000000000000000000000000000000000000000000000000004
    callsub testUintN
    // tests/approvals/arc4-types.algo.ts:196
    // testUFixed()
    callsub testUFixed
    // tests/approvals/arc4-types.algo.ts:197
    // testByte()
    callsub testByte
    // tests/approvals/arc4-types.algo.ts:198
    // testArrays(new Uint<64>(65))
    pushbytes 0x0000000000000041
    callsub testArrays
    // tests/approvals/arc4-types.algo.ts:199
    // testAddress()
    callsub testAddress
    // tests/approvals/arc4-types.algo.ts:200
    // testTuple()
    callsub testTuple
    // tests/approvals/arc4-types.algo.ts:201
    // testUFixed()
    callsub testUFixed
    // tests/approvals/arc4-types.algo.ts:202
    // testDynamicBytes(Bytes('hmmmmmmmmm'))
    pushbytes "hmmmmmmmmm"
    callsub testDynamicBytes
    // tests/approvals/arc4-types.algo.ts:203
    // testStaticBytes()
    callsub testStaticBytes
    // tests/approvals/arc4-types.algo.ts:204
    // testZeroValues()
    callsub testZeroValues
    // tests/approvals/arc4-types.algo.ts:205
    // const result = new arc4.DynamicArray<arc4.Uint<64>>()
    intc_0 // 0
    itob
    extract 6 2
    // tests/approvals/arc4-types.algo.ts:206
    // assert(result.length === 0)
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_0 // 0
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:207
    // testAsUint64()
    callsub testAsUint64
    // tests/approvals/arc4-types.algo.ts:208
    // testAsBigUint()
    callsub testAsBigUint
    // tests/approvals/arc4-types.algo.ts:209
    // return true
    intc_3 // 1
    return


// _puya_lib.util.ensure_budget(required_budget: uint64, fee_source: uint64) -> void:
ensure_budget:
    proto 2 0
    b ensure_budget_block@0

ensure_budget_block@0:
    frame_dig -2
    pushint 10
    +
    b ensure_budget_while_top@1

ensure_budget_while_top@1:
    global OpcodeBudget
    frame_dig 0
    <
    bz ensure_budget_after_while@6
    b ensure_budget_while_body@2

ensure_budget_while_body@2:
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 13 // 0x068101
    itxn_field ApprovalProgram
    bytec 13 // 0x068101
    itxn_field ClearStateProgram
    intc_0 // 0
    intc_3 // 1
    frame_dig -1
    match ensure_budget_switch_case_0@3 ensure_budget_switch_case_1@4
    b ensure_budget_switch_case_next@5

ensure_budget_switch_case_next@5:
    itxn_submit
    b ensure_budget_while_top@1

ensure_budget_switch_case_1@4:
    global MinTxnFee
    itxn_field Fee
    b ensure_budget_switch_case_next@5

ensure_budget_switch_case_0@3:
    intc_0 // 0
    itxn_field Fee
    b ensure_budget_switch_case_next@5

ensure_budget_after_while@6:
    retsub


// tests/approvals/arc4-types.algo.ts::testUFixed() -> void:
testUFixed:
    b testUFixed_block@0

testUFixed_block@0:
    // tests/approvals/arc4-types.algo.ts:27
    // assert(a === c)
    bytec 14 // 0x000004dc
    bytec 14 // 0x000004dc
    ==
    assert
    retsub


// tests/approvals/arc4-types.algo.ts::testUintN(n: uint64, b: bytes, c: bytes) -> void:
testUintN:
    // tests/approvals/arc4-types.algo.ts:30
    // function testUintN(n: uint64, b: biguint, c: Uint<256>) {
    proto 3 0
    b testUintN_block@0

testUintN_block@0:
    // tests/approvals/arc4-types.algo.ts:32
    // assert(x.bytes.length === 1)
    pushbytes 0x04
    len
    intc_3 // 1
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:34
    // assert(x2.bytes === Bytes.fromHex('ff'))
    bytec 6 // 0xff
    bytec 6 // 0xff
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:37
    // assert(y.bytes.length === 2)
    bytec_3 // 0x0000
    len
    intc_2 // 2
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:38
    // const z = new Uint<8>(n)
    frame_dig -3
    itob
    dup
    bitlen
    intc_1 // 8
    <=
    assert // overflow
    pushint 7
    intc_3 // 1
    extract3
    // tests/approvals/arc4-types.algo.ts:39
    // const z_native = z.asUint64()
    btoi
    // tests/approvals/arc4-types.algo.ts:40
    // assert(z_native === n)
    frame_dig -3
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:43
    // const a = new Uint<128>(b)
    frame_dig -2
    len
    pushint 16
    <=
    assert // overflow
    pushint 16
    bzero
    frame_dig -2
    b|
    // tests/approvals/arc4-types.algo.ts:44
    // const a_native = a.asBigUint()
    dup
    // tests/approvals/arc4-types.algo.ts:45
    // assert(a_native === b)
    frame_dig -2
    b==
    assert
    // tests/approvals/arc4-types.algo.ts:47
    // assert(c.bytes.length === 256 / 8)
    frame_dig -1
    len
    pushint 32
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:49
    // const a_bytes = a.bytes
    dupn 2
    // tests/approvals/arc4-types.algo.ts:50
    // const a_from_bytes = convertBytes<Uint<128>>(a_bytes, { strategy: 'validate' })
    len
    pushint 16
    ==
    assert // invalid number of bytes for arc4.uint128
    // tests/approvals/arc4-types.algo.ts:52
    // assert(a_from_bytes === a)
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:56
    // assert(aliased64.asUint64() === 12)
    pushbytes 0x000000000000000c
    btoi
    pushint 12
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:58
    // assert(BigUint(aliased32.bytes) === 50545n)
    pushbytes 0x0000c571
    pushbytes 0xc571
    b==
    assert
    // tests/approvals/arc4-types.algo.ts:62
    // assert(byte.bytes.bitwiseInvert() === Bytes.fromHex('00'))
    bytec 6 // 0xff
    b~
    bytec_0 // 0x00
    ==
    assert
    retsub


// tests/approvals/arc4-types.algo.ts::testStr() -> void:
testStr:
    b testStr_block@0

testStr_block@0:
    // tests/approvals/arc4-types.algo.ts:67
    // assert(s1.bytes === new Uint<16>(0).bytes, 'Empty string should equal the uint16 length prefix')
    bytec_1 // ""
    len
    itob
    extract 6 2
    bytec_1 // ""
    concat
    bytec_3 // 0x0000
    ==
    assert // Empty string should equal the uint16 length prefix
    // tests/approvals/arc4-types.algo.ts:69
    // assert(s2.native === 'Hello')
    bytec_2 // "Hello"
    len
    itob
    extract 6 2
    bytec_2 // "Hello"
    concat
    extract 2 0
    bytec_2 // "Hello"
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:71
    // const s2_bytes = s2.bytes
    bytec_2 // "Hello"
    len
    itob
    extract 6 2
    bytec_2 // "Hello"
    concat
    // tests/approvals/arc4-types.algo.ts:73
    // const s2_from_bytes = convertBytes<Str>(s2_bytes, { strategy: 'validate' })
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 1
    *
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    // tests/approvals/arc4-types.algo.ts:75
    // assert(s2 === s2_from_bytes)
    bytec_2 // "Hello"
    len
    itob
    extract 6 2
    bytec_2 // "Hello"
    concat
    ==
    assert
    retsub


// tests/approvals/arc4-types.algo.ts::testDynamicBytes(someBytes: bytes) -> void:
testDynamicBytes:
    // tests/approvals/arc4-types.algo.ts:78
    // function testDynamicBytes(someBytes: bytes) {
    proto 1 0
    intc_0 // 0
    b testDynamicBytes_block@0

testDynamicBytes_block@0:
    // tests/approvals/arc4-types.algo.ts:80
    // assert(db1.native === Bytes(), 'No args should give empty bytes')
    bytec_3 // 0x0000
    extract 2 0
    bytec_1 // 0x
    ==
    assert // No args should give empty bytes
    // tests/approvals/arc4-types.algo.ts:81
    // assert(db1.bytes === new Uint<16>(0).bytes, 'bytes prop should return length header (of 0)')
    bytec_3 // 0x0000
    bytec_3 // 0x0000
    ==
    assert // bytes prop should return length header (of 0)
    // tests/approvals/arc4-types.algo.ts:82
    // const db2 = new DynamicBytes(someBytes)
    frame_dig -1
    len
    itob
    extract 6 2
    frame_dig -1
    concat
    // tests/approvals/arc4-types.algo.ts:83
    // assert(db2.native === someBytes)
    extract 2 0
    frame_dig -1
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:86
    // assert(db3.native === Bytes('hello'))
    bytec 7 // 0x000568656c6c6f
    extract 2 0
    pushbytes "hello"
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:88
    // const db4 = db3.concat(new DynamicBytes(' world'))
    bytec 8 // 0x000620776f726c64
    len
    bytec 8 // 0x000620776f726c64
    intc_2 // 2
    uncover 2
    substring3
    bytec 8 // 0x000620776f726c64
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    b testDynamicBytes_block@1

testDynamicBytes_block@1:
    // tests/approvals/arc4-types.algo.ts:88
    // const db4 = db3.concat(new DynamicBytes(' world'))
    bytec 7 // 0x000568656c6c6f
    intc_0 // 0
    extract_uint16
    frame_dig 2
    +
    itob
    extract 6 0
    // tests/approvals/arc4-types.algo.ts:88
    // const db4 = db3.concat(new DynamicBytes(' world'))
    bytec 7 // 0x000568656c6c6f
    uncover 1
    replace2 0
    frame_dig 1
    concat
    frame_bury 0
    // tests/approvals/arc4-types.algo.ts:88
    // const db4 = db3.concat(new DynamicBytes(' world'))
    b testDynamicBytes_after_inlined__puya_lib.arc4.dynamic_array_concat_fixed@2

testDynamicBytes_after_inlined__puya_lib.arc4.dynamic_array_concat_fixed@2:
    // tests/approvals/arc4-types.algo.ts:88
    // const db4 = db3.concat(new DynamicBytes(' world'))
    frame_dig 0
    // tests/approvals/arc4-types.algo.ts:89
    // assert(db4.native === Bytes('hello world'))
    extract 2 0
    pushbytes "hello world"
    ==
    assert
    retsub


// tests/approvals/arc4-types.algo.ts::testStaticBytes() -> void:
testStaticBytes:
    // tests/approvals/arc4-types.algo.ts:92
    // function testStaticBytes() {
    proto 0 0
    intc_0 // 0
    b testStaticBytes_block@0

testStaticBytes_block@0:
    // tests/approvals/arc4-types.algo.ts:97
    // const s5 = new StaticArray<StaticBytes<5>, 1>(new StaticBytes<5>(Bytes.fromHex('AABBCCDDEE')))
    bytec_1 // 0x
    bytec 9 // 0xaabbccddee
    concat
    // tests/approvals/arc4-types.algo.ts:98
    // assert(s5[0].native === Bytes.fromHex('AABBCCDDEE'))
    intc_0 // 0
    pushint 5
    *
    pushint 5
    extract3 // on error: index access is out of bounds
    bytec 9 // 0xaabbccddee
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:100
    // const s4 = s2.concat(s3)
    b testStaticBytes_block@1

testStaticBytes_block@1:
    // tests/approvals/arc4-types.algo.ts:100
    // const s4 = s2.concat(s3)
    bytec 15 // 0x000400000000
    intc_0 // 0
    extract_uint16
    // tests/approvals/arc4-types.algo.ts:100
    // const s4 = s2.concat(s3)
    pushint 5
    +
    itob
    extract 6 0
    // tests/approvals/arc4-types.algo.ts:100
    // const s4 = s2.concat(s3)
    bytec 15 // 0x000400000000
    uncover 1
    replace2 0
    // tests/approvals/arc4-types.algo.ts:100
    // const s4 = s2.concat(s3)
    bytec 9 // 0xaabbccddee
    concat
    frame_bury 0
    // tests/approvals/arc4-types.algo.ts:100
    // const s4 = s2.concat(s3)
    b testStaticBytes_after_inlined__puya_lib.arc4.dynamic_array_concat_fixed@2

testStaticBytes_after_inlined__puya_lib.arc4.dynamic_array_concat_fixed@2:
    // tests/approvals/arc4-types.algo.ts:100
    // const s4 = s2.concat(s3)
    frame_dig 0
    // tests/approvals/arc4-types.algo.ts:101
    // assert(s4.native === Bytes.fromHex('00000000AABBCCDDEE'))
    extract 2 0
    pushbytes 0x00000000aabbccddee
    ==
    assert
    retsub


// tests/approvals/arc4-types.algo.ts::testArrays(n: bytes) -> void:
testArrays:
    // tests/approvals/arc4-types.algo.ts:107
    // function testArrays(n: ARC4Uint64) {
    proto 1 0
    intc_0 // 0
    intc_0 // 0
    intc_0 // 0
    bytec_1 // ""
    b testArrays_block@0

testArrays_block@0:
    // tests/approvals/arc4-types.algo.ts:108
    // const myArray = new DynamicArray(n, n, n)
    pushint 3
    itob
    extract 6 2
    frame_dig -1
    concat
    frame_dig -1
    concat
    frame_dig -1
    concat
    // tests/approvals/arc4-types.algo.ts:110
    // myArray.push(n)
    bytec_1 // 0x
    frame_dig -1
    concat
    b testArrays_block@1

testArrays_block@1:
    frame_dig 4
    dup
    intc_0 // 0
    extract_uint16
    // tests/approvals/arc4-types.algo.ts:110
    // myArray.push(n)
    intc_3 // 1
    +
    itob
    extract 6 0
    replace2 0
    frame_dig 5
    concat
    frame_bury 0
    // tests/approvals/arc4-types.algo.ts:110
    // myArray.push(n)
    b testArrays_after_inlined__puya_lib.arc4.dynamic_array_concat_fixed@2

testArrays_after_inlined__puya_lib.arc4.dynamic_array_concat_fixed@2:
    // tests/approvals/arc4-types.algo.ts:110
    // myArray.push(n)
    frame_dig 0
    dup
    frame_bury 2
    // tests/approvals/arc4-types.algo.ts:112
    // const doubleArray = myArray.concat(myArray)
    dup
    len
    cover 1
    dup
    intc_2 // 2
    uncover 3
    substring3
    cover 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    uncover 1
    frame_bury 4
    uncover 1
    frame_bury 5
    frame_bury 3
    b testArrays_block@3

testArrays_block@3:
    frame_dig 4
    dup
    intc_0 // 0
    extract_uint16
    frame_dig 3
    +
    itob
    extract 6 0
    replace2 0
    frame_dig 5
    concat
    frame_bury 1
    // tests/approvals/arc4-types.algo.ts:112
    // const doubleArray = myArray.concat(myArray)
    b testArrays_after_inlined__puya_lib.arc4.dynamic_array_concat_fixed@4

testArrays_after_inlined__puya_lib.arc4.dynamic_array_concat_fixed@4:
    // tests/approvals/arc4-types.algo.ts:112
    // const doubleArray = myArray.concat(myArray)
    frame_dig 1
    // tests/approvals/arc4-types.algo.ts:114
    // assert(doubleArray === new DynamicArray(n, n, n, n, n, n, n, n))
    intc_1 // 8
    itob
    extract 6 2
    frame_dig -1
    concat
    frame_dig -1
    concat
    frame_dig -1
    concat
    frame_dig -1
    concat
    frame_dig -1
    concat
    frame_dig -1
    concat
    frame_dig -1
    concat
    frame_dig -1
    concat
    dig 1
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:116
    // const myStatic = new StaticArray(n, n)
    bytec_1 // 0x
    frame_dig -1
    concat
    frame_dig -1
    concat
    // tests/approvals/arc4-types.algo.ts:118
    // assert(myStatic[0] === myArray.pop())
    intc_0 // 0
    intc_1 // 8
    *
    intc_1 // 8
    extract3 // on error: index access is out of bounds
    frame_dig 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 1
    -
    dig 1
    len
    cover 1
    uncover 2
    intc_2 // 2
    uncover 3
    substring3
    uncover 1
    intc_1 // 8
    *
    intc_1 // 8
    extract3 // on error: index access is out of bounds
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:122
    // const myStatic2 = new StaticArray<ARC4Uint64, 3>(n, n, n)
    bytec_1 // 0x
    frame_dig -1
    concat
    frame_dig -1
    concat
    frame_dig -1
    concat
    // tests/approvals/arc4-types.algo.ts:124
    // assertMatch(myStatic2, [n, n, n])
    pushint 3
    pushint 3
    ==
    cover 1
    intc_0 // 0
    intc_1 // 8
    *
    dig 1
    uncover 1
    intc_1 // 8
    extract3 // on error: index access is out of bounds
    frame_dig -1
    ==
    uncover 2
    &&
    intc_3 // 1
    intc_1 // 8
    *
    dig 2
    uncover 1
    intc_1 // 8
    extract3 // on error: index access is out of bounds
    frame_dig -1
    ==
    &&
    intc_2 // 2
    intc_1 // 8
    *
    uncover 2
    uncover 1
    intc_1 // 8
    extract3 // on error: index access is out of bounds
    frame_dig -1
    ==
    &&
    assert // assert target is match for conditions
    // tests/approvals/arc4-types.algo.ts:126
    // assertMatch(doubleArray, [n, n, n, n, n, n, n, n])
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 8
    ==
    cover 1
    dup
    len
    cover 1
    dup
    intc_2 // 2
    uncover 3
    substring3
    intc_0 // 0
    intc_1 // 8
    *
    intc_1 // 8
    extract3 // on error: index access is out of bounds
    frame_dig -1
    ==
    uncover 2
    &&
    cover 1
    dup
    len
    cover 1
    dup
    intc_2 // 2
    uncover 3
    substring3
    intc_3 // 1
    intc_1 // 8
    *
    intc_1 // 8
    extract3 // on error: index access is out of bounds
    frame_dig -1
    ==
    uncover 2
    &&
    cover 1
    dup
    len
    cover 1
    dup
    intc_2 // 2
    uncover 3
    substring3
    intc_2 // 2
    intc_1 // 8
    *
    intc_1 // 8
    extract3 // on error: index access is out of bounds
    frame_dig -1
    ==
    uncover 2
    &&
    cover 1
    dup
    len
    cover 1
    dup
    intc_2 // 2
    uncover 3
    substring3
    pushint 3
    intc_1 // 8
    *
    intc_1 // 8
    extract3 // on error: index access is out of bounds
    frame_dig -1
    ==
    uncover 2
    &&
    cover 1
    dup
    len
    cover 1
    dup
    intc_2 // 2
    uncover 3
    substring3
    pushint 4
    intc_1 // 8
    *
    intc_1 // 8
    extract3 // on error: index access is out of bounds
    frame_dig -1
    ==
    uncover 2
    &&
    cover 1
    dup
    len
    cover 1
    dup
    intc_2 // 2
    uncover 3
    substring3
    pushint 5
    intc_1 // 8
    *
    intc_1 // 8
    extract3 // on error: index access is out of bounds
    frame_dig -1
    ==
    uncover 2
    &&
    cover 1
    dup
    len
    cover 1
    dup
    intc_2 // 2
    uncover 3
    substring3
    pushint 6
    intc_1 // 8
    *
    intc_1 // 8
    extract3 // on error: index access is out of bounds
    frame_dig -1
    ==
    uncover 2
    &&
    cover 1
    dup
    len
    cover 1
    intc_2 // 2
    uncover 2
    substring3
    pushint 7
    intc_1 // 8
    *
    intc_1 // 8
    extract3 // on error: index access is out of bounds
    frame_dig -1
    ==
    &&
    assert // assert target is match for conditions
    retsub


// tests/approvals/arc4-types.algo.ts::testByte() -> void:
testByte:
    b testByte_block@0

testByte_block@0:
    // tests/approvals/arc4-types.algo.ts:132
    // assert(b === b2)
    bytec_0 // 0x00
    bytec_0 // 0x00
    ==
    assert
    retsub


// tests/approvals/arc4-types.algo.ts::testAddress() -> void:
testAddress:
    b testAddress_block@0

testAddress_block@0:
    // tests/approvals/arc4-types.algo.ts:137
    // const b = new Address(Txn.sender)
    txn Sender
    // tests/approvals/arc4-types.algo.ts:139
    // assert(b.native === Txn.sender)
    dup
    txn Sender
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:141
    // assert(a !== b, 'Zero address should not match sender')
    bytec 4 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    !=
    assert // Zero address should not match sender
    // tests/approvals/arc4-types.algo.ts:142
    // assert(a === new Address(), 'Two zero addresses should match')
    bytec 4 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    bytec 4 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    ==
    assert // Two zero addresses should match
    // tests/approvals/arc4-types.algo.ts:143
    // assert(a[0] === new Byte(), 'Zero address should start with zero byte')
    intc_0 // 0
    intc_3 // 1
    *
    bytec 4 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    uncover 1
    intc_3 // 1
    extract3 // on error: index access is out of bounds
    bytec_0 // 0x00
    ==
    assert // Zero address should start with zero byte
    retsub


// tests/approvals/arc4-types.algo.ts::testTuple() -> void:
testTuple:
    b testTuple_block@0

testTuple_block@0:
    // tests/approvals/arc4-types.algo.ts:147
    // const t = new Tuple(new ARC4Uint64(34))
    bytec_1 // 0x
    pushbytes 0x0000000000000022
    concat
    // tests/approvals/arc4-types.algo.ts:148
    // const firstItem = t.at(0)
    dup
    intc_0 // 0
    intc_1 // 8
    extract3
    cover 1
    // tests/approvals/arc4-types.algo.ts:149
    // const firstItemIndexer = t.native[0]
    intc_0 // 0
    intc_1 // 8
    extract3
    // tests/approvals/arc4-types.algo.ts:150
    // assert(firstItem === firstItemIndexer)
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:152
    // assert(t1.length === 2)
    intc_2 // 2
    intc_2 // 2
    ==
    assert
    retsub


// tests/approvals/arc4-types.algo.ts::testAsUint64() -> void:
testAsUint64:
    b testAsUint64_block@0

testAsUint64_block@0:
    // tests/approvals/arc4-types.algo.ts:158
    // assert(u8.asUint64() === 42)
    bytec 10 // 0x2a
    btoi
    pushint 42
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:161
    // assert(u64.asUint64() === Uint64(MAX_UINT64))
    bytec 11 // 0xffffffffffffffff
    btoi
    intc 4 // 18446744073709551615
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:164
    // assert(uint128.asUint64() === 1)
    bytec 5 // 0x00000000000000000000000000000001
    bitlen
    pushint 64
    <=
    assert // overflow
    bytec 5 // 0x00000000000000000000000000000001
    len
    intc_1 // 8
    -
    bytec 5 // 0x00000000000000000000000000000001
    uncover 1
    extract_uint64
    intc_3 // 1
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:167
    // assert(uint256.asUint64() === Uint64(MAX_UINT64))
    bytec 12 // 0x000000000000000000000000000000000000000000000000ffffffffffffffff
    bitlen
    pushint 64
    <=
    assert // overflow
    bytec 12 // 0x000000000000000000000000000000000000000000000000ffffffffffffffff
    len
    intc_1 // 8
    -
    bytec 12 // 0x000000000000000000000000000000000000000000000000ffffffffffffffff
    uncover 1
    extract_uint64
    intc 4 // 18446744073709551615
    ==
    assert
    retsub


// tests/approvals/arc4-types.algo.ts::testAsBigUint() -> void:
testAsBigUint:
    b testAsBigUint_block@0

testAsBigUint_block@0:
    // tests/approvals/arc4-types.algo.ts:172
    // assert(u8.asBigUint() === 42n)
    bytec 10 // 0x2a
    bytec 10 // 0x2a
    b==
    assert
    // tests/approvals/arc4-types.algo.ts:176
    // assert(u64.asBigUint() === BigUint(MAX_UINT64))
    bytec 11 // 0xffffffffffffffff
    bytec 11 // 0xffffffffffffffff
    b==
    assert
    // tests/approvals/arc4-types.algo.ts:179
    // assert(uint128.asBigUint() === 1n)
    bytec 5 // 0x00000000000000000000000000000001
    pushbytes 0x01
    b==
    assert
    // tests/approvals/arc4-types.algo.ts:183
    // assert(uint256.asBigUint() === BigUint(MAX_UINT256))
    bytec 16 // 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    bytec 16 // 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    b==
    assert
    retsub


// tests/approvals/arc4-types.algo.ts::testZeroValues() -> void:
testZeroValues:
    b testZeroValues_block@0

testZeroValues_block@0:
    // tests/approvals/arc4-types.algo.ts:214
    // assert(new StaticArray<Uint8, 4>().bytes === new StaticArray(new Uint8(0), new Uint8(0), new Uint8(0), new Uint8(0)).bytes)
    pushint 4
    bzero
    bytec_1 // 0x
    bytec_0 // 0x00
    concat
    bytec_0 // 0x00
    concat
    bytec_0 // 0x00
    concat
    bytec_0 // 0x00
    concat
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:215
    // assert(new StaticArray<Bool, 4>().bytes === new StaticArray(new Bool(false), new Bool(false), new Bool(false), new Bool(false)).bytes)
    intc_3 // 1
    bzero
    bytec_0 // 0x00
    intc_0 // 0
    intc_0 // 0
    setbit
    bytec_0 // 0x00
    intc_0 // 0
    intc_0 // 0
    setbit
    bytec_0 // 0x00
    intc_0 // 0
    intc_0 // 0
    setbit
    cover 1
    bytec_0 // 0x00
    intc_0 // 0
    intc_0 // 0
    setbit
    cover 2
    intc_0 // 0
    getbit
    uncover 3
    intc_3 // 1
    uncover 2
    setbit
    uncover 1
    intc_0 // 0
    getbit
    uncover 1
    intc_2 // 2
    uncover 2
    setbit
    uncover 1
    intc_0 // 0
    getbit
    uncover 1
    pushint 3
    uncover 2
    setbit
    bytec_1 // 0x
    uncover 1
    concat
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:217
    // new StaticArray<Bool, 9>().bytes ===
    intc_2 // 2
    bzero
    // tests/approvals/arc4-types.algo.ts:219
    // new Bool(false),
    bytec_0 // 0x00
    intc_0 // 0
    intc_0 // 0
    setbit
    // tests/approvals/arc4-types.algo.ts:220
    // new Bool(false),
    bytec_0 // 0x00
    intc_0 // 0
    intc_0 // 0
    setbit
    // tests/approvals/arc4-types.algo.ts:221
    // new Bool(false),
    bytec_0 // 0x00
    intc_0 // 0
    intc_0 // 0
    setbit
    cover 1
    // tests/approvals/arc4-types.algo.ts:222
    // new Bool(false),
    bytec_0 // 0x00
    intc_0 // 0
    intc_0 // 0
    setbit
    cover 2
    // tests/approvals/arc4-types.algo.ts:223
    // new Bool(false),
    bytec_0 // 0x00
    intc_0 // 0
    intc_0 // 0
    setbit
    cover 3
    // tests/approvals/arc4-types.algo.ts:224
    // new Bool(false),
    bytec_0 // 0x00
    intc_0 // 0
    intc_0 // 0
    setbit
    cover 4
    // tests/approvals/arc4-types.algo.ts:225
    // new Bool(false),
    bytec_0 // 0x00
    intc_0 // 0
    intc_0 // 0
    setbit
    cover 5
    // tests/approvals/arc4-types.algo.ts:226
    // new Bool(false),
    bytec_0 // 0x00
    intc_0 // 0
    intc_0 // 0
    setbit
    cover 6
    // tests/approvals/arc4-types.algo.ts:227
    // new Bool(false),
    bytec_0 // 0x00
    intc_0 // 0
    intc_0 // 0
    setbit
    cover 7
    // tests/approvals/arc4-types.algo.ts:218-228
    // new StaticArray(
    //   new Bool(false),
    //   new Bool(false),
    //   new Bool(false),
    //   new Bool(false),
    //   new Bool(false),
    //   new Bool(false),
    //   new Bool(false),
    //   new Bool(false),
    //   new Bool(false),
    // ).bytes,
    intc_0 // 0
    getbit
    uncover 8
    intc_3 // 1
    uncover 2
    setbit
    uncover 1
    intc_0 // 0
    getbit
    uncover 1
    intc_2 // 2
    uncover 2
    setbit
    uncover 1
    intc_0 // 0
    getbit
    uncover 1
    pushint 3
    uncover 2
    setbit
    uncover 1
    intc_0 // 0
    getbit
    uncover 1
    pushint 4
    uncover 2
    setbit
    uncover 1
    intc_0 // 0
    getbit
    uncover 1
    pushint 5
    uncover 2
    setbit
    uncover 1
    intc_0 // 0
    getbit
    uncover 1
    pushint 6
    uncover 2
    setbit
    uncover 1
    intc_0 // 0
    getbit
    uncover 1
    pushint 7
    uncover 2
    setbit
    bytec_1 // 0x
    uncover 1
    concat
    uncover 1
    concat
    // tests/approvals/arc4-types.algo.ts:217-228
    // new StaticArray<Bool, 9>().bytes ===
    //   new StaticArray(
    //     new Bool(false),
    //     new Bool(false),
    //     new Bool(false),
    //     new Bool(false),
    //     new Bool(false),
    //     new Bool(false),
    //     new Bool(false),
    //     new Bool(false),
    //     new Bool(false),
    //   ).bytes,
    ==
    // tests/approvals/arc4-types.algo.ts:216-229
    // assert(
    //   new StaticArray<Bool, 9>().bytes ===
    //     new StaticArray(
    //       new Bool(false),
    //       new Bool(false),
    //       new Bool(false),
    //       new Bool(false),
    //       new Bool(false),
    //       new Bool(false),
    //       new Bool(false),
    //       new Bool(false),
    //       new Bool(false),
    //     ).bytes,
    // )
    assert
    // tests/approvals/arc4-types.algo.ts:230
    // assert(new DynamicArray<Uint8>().bytes === bzero(2))
    intc_0 // 0
    itob
    extract 6 2
    intc_2 // 2
    bzero
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:232
    // new Tuple<[Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool]>().bytes ===
    intc_2 // 2
    bzero
    // tests/approvals/arc4-types.algo.ts:233
    // encodeArc4([false, false, false, false, false, false, false, false, false]),
    bytec_0 // 0x00
    intc_0 // 0
    intc_0 // 0
    setbit
    intc_3 // 1
    intc_0 // 0
    setbit
    intc_2 // 2
    intc_0 // 0
    setbit
    pushint 3
    intc_0 // 0
    setbit
    pushint 4
    intc_0 // 0
    setbit
    pushint 5
    intc_0 // 0
    setbit
    pushint 6
    intc_0 // 0
    setbit
    pushint 7
    intc_0 // 0
    setbit
    bytec_1 // 0x
    uncover 1
    concat
    bytec_0 // 0x00
    intc_0 // 0
    intc_0 // 0
    setbit
    concat
    // tests/approvals/arc4-types.algo.ts:232-233
    // new Tuple<[Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool]>().bytes ===
    //   encodeArc4([false, false, false, false, false, false, false, false, false]),
    ==
    // tests/approvals/arc4-types.algo.ts:231-234
    // assert(
    //   new Tuple<[Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool]>().bytes ===
    //     encodeArc4([false, false, false, false, false, false, false, false, false]),
    // )
    assert
    // tests/approvals/arc4-types.algo.ts:235
    // assert(new Str().bytes === bzero(2))
    bytec_1 // ""
    len
    itob
    extract 6 2
    bytec_1 // ""
    concat
    intc_2 // 2
    bzero
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:236
    // assert(new DynamicBytes().bytes === bzero(2))
    intc_2 // 2
    bzero
    bytec_3 // 0x0000
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:237
    // assert(new StaticBytes<5>().bytes === bzero(5))
    pushint 5
    bzero
    pushbytes 0x0000000000
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:238
    // assert(new Address().bytes === bzero(32))
    pushint 32
    bzero
    bytec 4 // addr AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:239
    // assert(new UFixed<32, 4>().bytes === bzero(32 / 8))
    pushint 4
    bzero
    bytec 17 // 0x00000000
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:240
    // assert(new Bool().bytes === bzero(1))
    bytec_0 // 0x00
    intc_0 // 0
    intc_0 // 0
    setbit
    intc_3 // 1
    bzero
    ==
    assert
    // tests/approvals/arc4-types.algo.ts:241
    // assert(new Uint32().bytes === bzero(32 / 8))
    pushint 4
    bzero
    bytec 17 // 0x00000000
    ==
    assert
    retsub
