#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 8 1 16
    bytecblock 0x 0x151f7c75 "plugins" 0x0000000000000000

main_block@0:

main_block@1:
    // tests/approvals/mutable-object.algo.ts:10
    // export class MutableObjectDemo extends Contract {
    txn NumAppArgs
    intc_0 // 0
    !=
    bz main_bare_routing@12

main_abi_routing@2:
    // tests/approvals/mutable-object.algo.ts:10
    // export class MutableObjectDemo extends Contract {
    txna ApplicationArgs 0
    pushbytes 0x89388ddd // method "testVectorCreationAndEquality()void"
    pushbytes 0xef322d6d // method "addVectors((uint64,uint64),(uint64,uint64))(uint64,uint64)"
    pushbytes 0x02458807 // method "mutateVector((uint64,uint64),uint64,uint64)(uint64,uint64)"
    pushbytes 0xcb81deb8 // method "implicitCastingAndSpreading((uint64,uint64))void"
    pushbytes 0x95d82d6f // method "getPlugin(string)(uint64,uint64,uint64,bool)"
    pushbytes 0x86bb6481 // method "getMain()(uint64,uint64,uint64,bool)"
    pushbytes 0xa9bc61f1 // method "setPlugin(string)void"
    uncover 7
    match main_testVectorCreationAndEquality_route@3 main_addVectors_route@4 main_mutateVector_route@5 main_implicitCastingAndSpreading_route@6 main_getPlugin_route@7 main_getMain_route@8 main_setPlugin_route@9

main_switch_case_default@10:

main_switch_case_next@11:

main_after_if_else@16:
    // tests/approvals/mutable-object.algo.ts:10
    // export class MutableObjectDemo extends Contract {
    intc_0 // 0

main_after_inlined_tests/approvals/mutable-object.algo.ts::MutableObjectDemo.__puya_arc4_router__@17:
    return

main_setPlugin_route@9:
    // tests/approvals/mutable-object.algo.ts:61
    // public setPlugin(key: string) {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // tests/approvals/mutable-object.algo.ts:10
    // export class MutableObjectDemo extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // tests/approvals/mutable-object.algo.ts:61
    // public setPlugin(key: string) {
    callsub setPlugin
    intc_2 // 1
    b main_after_inlined_tests/approvals/mutable-object.algo.ts::MutableObjectDemo.__puya_arc4_router__@17

main_getMain_route@8:
    // tests/approvals/mutable-object.algo.ts:51
    // public getMain() {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    callsub getMain
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    b main_after_inlined_tests/approvals/mutable-object.algo.ts::MutableObjectDemo.__puya_arc4_router__@17

main_getPlugin_route@7:
    // tests/approvals/mutable-object.algo.ts:45
    // public getPlugin(key: string): PluginInfo {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // tests/approvals/mutable-object.algo.ts:10
    // export class MutableObjectDemo extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // tests/approvals/mutable-object.algo.ts:45
    // public getPlugin(key: string): PluginInfo {
    callsub getPlugin
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    b main_after_inlined_tests/approvals/mutable-object.algo.ts::MutableObjectDemo.__puya_arc4_router__@17

main_implicitCastingAndSpreading_route@6:
    // tests/approvals/mutable-object.algo.ts:32
    // public implicitCastingAndSpreading(v1: Vector) {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // tests/approvals/mutable-object.algo.ts:10
    // export class MutableObjectDemo extends Contract {
    txna ApplicationArgs 1
    // tests/approvals/mutable-object.algo.ts:32
    // public implicitCastingAndSpreading(v1: Vector) {
    callsub implicitCastingAndSpreading
    intc_2 // 1
    b main_after_inlined_tests/approvals/mutable-object.algo.ts::MutableObjectDemo.__puya_arc4_router__@17

main_mutateVector_route@5:
    // tests/approvals/mutable-object.algo.ts:26
    // public mutateVector(v1: Vector, newX: uint64, newY: uint64): Vector {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // tests/approvals/mutable-object.algo.ts:10
    // export class MutableObjectDemo extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // tests/approvals/mutable-object.algo.ts:26
    // public mutateVector(v1: Vector, newX: uint64, newY: uint64): Vector {
    uncover 2
    uncover 2
    uncover 2
    callsub mutateVector
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    b main_after_inlined_tests/approvals/mutable-object.algo.ts::MutableObjectDemo.__puya_arc4_router__@17

main_addVectors_route@4:
    // tests/approvals/mutable-object.algo.ts:19
    // public addVectors(v1: Vector, v2: Vector) {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    // tests/approvals/mutable-object.algo.ts:10
    // export class MutableObjectDemo extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // tests/approvals/mutable-object.algo.ts:19
    // public addVectors(v1: Vector, v2: Vector) {
    callsub addVectors
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    b main_after_inlined_tests/approvals/mutable-object.algo.ts::MutableObjectDemo.__puya_arc4_router__@17

main_testVectorCreationAndEquality_route@3:
    // tests/approvals/mutable-object.algo.ts:11
    // public testVectorCreationAndEquality() {
    txn OnCompletion
    intc_0 // NoOp
    ==
    assert // OnCompletion is not NoOp
    txn ApplicationID
    intc_0 // 0
    !=
    assert // can only call when not creating
    callsub testVectorCreationAndEquality
    intc_2 // 1
    b main_after_inlined_tests/approvals/mutable-object.algo.ts::MutableObjectDemo.__puya_arc4_router__@17

main_bare_routing@12:
    // tests/approvals/mutable-object.algo.ts:10
    // export class MutableObjectDemo extends Contract {
    txn OnCompletion
    intc_0 // 0
    swap
    match main___algots__.defaultCreate@13

main_switch_case_default@14:

main_switch_case_next@15:
    b main_after_if_else@16

main___algots__.defaultCreate@13:
    // tests/approvals/mutable-object.algo.ts:10
    // export class MutableObjectDemo extends Contract {
    txn ApplicationID
    intc_0 // 0
    ==
    assert // can only call when creating
    callsub __algots__.defaultCreate
    intc_2 // 1
    b main_after_inlined_tests/approvals/mutable-object.algo.ts::MutableObjectDemo.__puya_arc4_router__@17


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testVectorCreationAndEquality() -> void:
testVectorCreationAndEquality:

testVectorCreationAndEquality_block@0:
    // tests/approvals/mutable-object.algo.ts:12
    // const v1 = new Vector({ x: 0, y: 0 })
    intc_0 // 0
    itob
    intc_0 // 0
    itob
    swap
    bytec_0 // 0x
    swap
    concat
    swap
    concat
    // tests/approvals/mutable-object.algo.ts:13
    // log(v1.x)
    dup
    intc_0 // 0
    intc_1 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    itob
    log
    // tests/approvals/mutable-object.algo.ts:14
    // log(v1.y)
    dup
    intc_1 // 8
    dup
    extract3 // on error: Index access is out of bounds
    btoi
    itob
    log
    // tests/approvals/mutable-object.algo.ts:15
    // const v2 = new Vector({ y: 0, x: 0 })
    intc_0 // 0
    itob
    intc_0 // 0
    itob
    swap
    bytec_0 // 0x
    swap
    concat
    swap
    concat
    // tests/approvals/mutable-object.algo.ts:16
    // assert(v1 === v2)
    ==
    assert
    retsub


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.addVectors(v1: bytes, v2: bytes) -> bytes:
addVectors:
    // tests/approvals/mutable-object.algo.ts:19
    // public addVectors(v1: Vector, v2: Vector) {
    proto 2 1

addVectors_block@0:
    // tests/approvals/mutable-object.algo.ts:21
    // x: v1.x + v2.x,
    frame_dig -2
    intc_0 // 0
    intc_1 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    frame_dig -1
    intc_0 // 0
    intc_1 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    +
    // tests/approvals/mutable-object.algo.ts:22
    // y: v1.y + v2.y,
    frame_dig -2
    intc_1 // 8
    dup
    extract3 // on error: Index access is out of bounds
    btoi
    frame_dig -1
    intc_1 // 8
    dup
    extract3 // on error: Index access is out of bounds
    btoi
    +
    // tests/approvals/mutable-object.algo.ts:21
    // x: v1.x + v2.x,
    swap
    itob
    swap
    // tests/approvals/mutable-object.algo.ts:22
    // y: v1.y + v2.y,
    itob
    swap
    // tests/approvals/mutable-object.algo.ts:20-23
    // return new Vector({
    //   x: v1.x + v2.x,
    //   y: v1.y + v2.y,
    // })
    bytec_0 // 0x
    swap
    concat
    swap
    concat
    retsub


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.mutateVector(v1: bytes, newX: uint64, newY: uint64) -> bytes:
mutateVector:
    // tests/approvals/mutable-object.algo.ts:26
    // public mutateVector(v1: Vector, newX: uint64, newY: uint64): Vector {
    proto 3 1

mutateVector_block@0:
    // tests/approvals/mutable-object.algo.ts:27
    // v1.x = newX
    frame_dig -2
    itob
    frame_dig -3
    intc_0 // 0
    uncover 2
    replace3
    frame_bury -3
    // tests/approvals/mutable-object.algo.ts:28
    // v1.y = newY
    frame_dig -1
    itob
    frame_dig -3
    intc_1 // 8
    uncover 2
    replace3
    dup
    frame_bury -3
    // tests/approvals/mutable-object.algo.ts:29
    // return v1
    retsub


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.implicitCastingAndSpreading(v1: bytes) -> void:
implicitCastingAndSpreading:
    // tests/approvals/mutable-object.algo.ts:32
    // public implicitCastingAndSpreading(v1: Vector) {
    proto 1 0

implicitCastingAndSpreading_block@0:
    // tests/approvals/mutable-object.algo.ts:33
    // const v2 = new Vector(v1)
    frame_dig -1
    intc_0 // 0
    intc_1 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    frame_dig -1
    intc_1 // 8
    dup
    extract3 // on error: Index access is out of bounds
    btoi
    swap
    itob
    swap
    itob
    swap
    bytec_0 // 0x
    swap
    concat
    swap
    concat
    // tests/approvals/mutable-object.algo.ts:34
    // const v3 = new Vector({ ...v2 })
    dup
    intc_0 // 0
    intc_1 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    swap
    dup
    intc_1 // 8
    dup
    extract3 // on error: Index access is out of bounds
    btoi
    uncover 2
    itob
    swap
    itob
    swap
    bytec_0 // 0x
    swap
    concat
    swap
    concat
    swap
    // tests/approvals/mutable-object.algo.ts:35
    // assert(v1.x === v2.x)
    frame_dig -1
    intc_0 // 0
    intc_1 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    dig 1
    intc_0 // 0
    intc_1 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    ==
    assert
    // tests/approvals/mutable-object.algo.ts:36
    // assert(v1.y === v2.y)
    frame_dig -1
    intc_1 // 8
    dup
    extract3 // on error: Index access is out of bounds
    btoi
    swap
    intc_1 // 8
    dup
    extract3 // on error: Index access is out of bounds
    btoi
    ==
    assert
    // tests/approvals/mutable-object.algo.ts:37
    // assert(v3.x === v1.x)
    dup
    intc_0 // 0
    intc_1 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    frame_dig -1
    intc_0 // 0
    intc_1 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    ==
    assert
    // tests/approvals/mutable-object.algo.ts:38
    // assert(v3.y === v1.y)
    intc_1 // 8
    dup
    extract3 // on error: Index access is out of bounds
    btoi
    frame_dig -1
    intc_1 // 8
    dup
    extract3 // on error: Index access is out of bounds
    btoi
    ==
    assert
    retsub


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.getPlugin(key: bytes) -> bytes:
getPlugin:
    // tests/approvals/mutable-object.algo.ts:45
    // public getPlugin(key: string): PluginInfo {
    proto 1 1

getPlugin_block@0:
    // tests/approvals/mutable-object.algo.ts:41
    // plugins = BoxMap<string, PluginInfo>({ keyPrefix: 'plugins' })
    bytec_2 // "plugins"
    frame_dig -1
    concat
    // tests/approvals/mutable-object.algo.ts:46
    // const value = this.plugins(key).value.copy()
    box_get
    assert // Box must have value
    // tests/approvals/mutable-object.algo.ts:47
    // assert(value.lastCalled.native > 0, 'Last called not zero')
    dup
    intc_3 // 16
    intc_1 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    intc_0 // 0
    >
    assert // Last called not zero
    // tests/approvals/mutable-object.algo.ts:48
    // return value
    retsub


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.getMain() -> bytes:
getMain:

getMain_block@0:
    // tests/approvals/mutable-object.algo.ts:43
    // plugin = Box<PluginInfo>({ key: 'main' })
    pushbytes "main"
    // tests/approvals/mutable-object.algo.ts:52
    // const value = this.plugin.value.copy()
    box_get
    assert // Box must have value
    // tests/approvals/mutable-object.algo.ts:53
    // assert(value.lastCalled.native > 0, 'Last called not zero')
    dup
    intc_3 // 16
    intc_1 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    intc_0 // 0
    >
    assert // Last called not zero
    // tests/approvals/mutable-object.algo.ts:54
    // return value
    retsub


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.setPlugin(key: bytes) -> void:
setPlugin:
    // tests/approvals/mutable-object.algo.ts:61
    // public setPlugin(key: string) {
    proto 1 0

setPlugin_block@0:
    // tests/approvals/mutable-object.algo.ts:62-74
    // this.plugins(key).value = new PluginInfo({
    //   lastValidRound: new arc4.UintN64(1),
    //   cooldown: new arc4.UintN64(),
    //   lastCalled: new arc4.UintN64(),
    //   adminPrivileges: new arc4.Bool(false),
    //   //   methods: [
    //   //     new MethodInfo({
    //   //       selector: new arc4.StaticBytes(methodSelector('test()void')),
    //   //       cooldown: new arc4.UintN64(1),
    //   //       lastCalled: new arc4.UintN64(1),
    //   //     }),
    //   //   ],
    // })
    bytec_0 // 0x
    // tests/approvals/mutable-object.algo.ts:63
    // lastValidRound: new arc4.UintN64(1),
    pushbytes 0x0000000000000001
    // tests/approvals/mutable-object.algo.ts:62-74
    // this.plugins(key).value = new PluginInfo({
    //   lastValidRound: new arc4.UintN64(1),
    //   cooldown: new arc4.UintN64(),
    //   lastCalled: new arc4.UintN64(),
    //   adminPrivileges: new arc4.Bool(false),
    //   //   methods: [
    //   //     new MethodInfo({
    //   //       selector: new arc4.StaticBytes(methodSelector('test()void')),
    //   //       cooldown: new arc4.UintN64(1),
    //   //       lastCalled: new arc4.UintN64(1),
    //   //     }),
    //   //   ],
    // })
    concat
    // tests/approvals/mutable-object.algo.ts:64
    // cooldown: new arc4.UintN64(),
    bytec_3 // 0x0000000000000000
    // tests/approvals/mutable-object.algo.ts:62-74
    // this.plugins(key).value = new PluginInfo({
    //   lastValidRound: new arc4.UintN64(1),
    //   cooldown: new arc4.UintN64(),
    //   lastCalled: new arc4.UintN64(),
    //   adminPrivileges: new arc4.Bool(false),
    //   //   methods: [
    //   //     new MethodInfo({
    //   //       selector: new arc4.StaticBytes(methodSelector('test()void')),
    //   //       cooldown: new arc4.UintN64(1),
    //   //       lastCalled: new arc4.UintN64(1),
    //   //     }),
    //   //   ],
    // })
    concat
    // tests/approvals/mutable-object.algo.ts:65
    // lastCalled: new arc4.UintN64(),
    bytec_3 // 0x0000000000000000
    // tests/approvals/mutable-object.algo.ts:62-74
    // this.plugins(key).value = new PluginInfo({
    //   lastValidRound: new arc4.UintN64(1),
    //   cooldown: new arc4.UintN64(),
    //   lastCalled: new arc4.UintN64(),
    //   adminPrivileges: new arc4.Bool(false),
    //   //   methods: [
    //   //     new MethodInfo({
    //   //       selector: new arc4.StaticBytes(methodSelector('test()void')),
    //   //       cooldown: new arc4.UintN64(1),
    //   //       lastCalled: new arc4.UintN64(1),
    //   //     }),
    //   //   ],
    // })
    concat
    // tests/approvals/mutable-object.algo.ts:66
    // adminPrivileges: new arc4.Bool(false),
    pushbytes 0x00
    // tests/approvals/mutable-object.algo.ts:62-74
    // this.plugins(key).value = new PluginInfo({
    //   lastValidRound: new arc4.UintN64(1),
    //   cooldown: new arc4.UintN64(),
    //   lastCalled: new arc4.UintN64(),
    //   adminPrivileges: new arc4.Bool(false),
    //   //   methods: [
    //   //     new MethodInfo({
    //   //       selector: new arc4.StaticBytes(methodSelector('test()void')),
    //   //       cooldown: new arc4.UintN64(1),
    //   //       lastCalled: new arc4.UintN64(1),
    //   //     }),
    //   //   ],
    // })
    concat
    // tests/approvals/mutable-object.algo.ts:41
    // plugins = BoxMap<string, PluginInfo>({ keyPrefix: 'plugins' })
    bytec_2 // "plugins"
    frame_dig -1
    concat
    // tests/approvals/mutable-object.algo.ts:62-74
    // this.plugins(key).value = new PluginInfo({
    //   lastValidRound: new arc4.UintN64(1),
    //   cooldown: new arc4.UintN64(),
    //   lastCalled: new arc4.UintN64(),
    //   adminPrivileges: new arc4.Bool(false),
    //   //   methods: [
    //   //     new MethodInfo({
    //   //       selector: new arc4.StaticBytes(methodSelector('test()void')),
    //   //       cooldown: new arc4.UintN64(1),
    //   //       lastCalled: new arc4.UintN64(1),
    //   //     }),
    //   //   ],
    // })
    swap
    box_put
    retsub


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.__algots__.defaultCreate() -> void:
__algots__.defaultCreate:

__algots__.defaultCreate_block@0:
    retsub
