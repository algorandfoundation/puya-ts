#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 8 0 16 1
    bytecblock 0x 0x151f7c75 0x02458807 0xba27a9ba 0x3814f92a 0x0000000000000001 "plugins" 0xa78000de 0x0000000000000000
    b main_block@0

main_block@0:
    b main_block@1

main_block@1:
    // tests/approvals/mutable-object.algo.ts:12
    // export class MutableObjectDemo extends Contract {
    txn NumAppArgs
    intc_1 // 0
    !=
    bz main___algots__.defaultCreate@18
    b main_abi_routing@2

main_abi_routing@2:
    // tests/approvals/mutable-object.algo.ts:12
    // export class MutableObjectDemo extends Contract {
    txn OnCompletion
    intc_1 // NoOp
    ==
    assert
    txn ApplicationID
    intc_1 // 0
    !=
    bz main_create_NoOp@16
    b main_call_NoOp@3

main_call_NoOp@3:
    // tests/approvals/mutable-object.algo.ts:12
    // export class MutableObjectDemo extends Contract {
    txna ApplicationArgs 0
    pushbytes 0x89388ddd // method "testVectorCreationAndEquality()void"
    pushbytes 0xef322d6d // method "addVectors((uint64,uint64),(uint64,uint64))(uint64,uint64)"
    bytec_2 // method "mutateVector((uint64,uint64),uint64,uint64)(uint64,uint64)"
    pushbytes 0xcb81deb8 // method "implicitCastingAndSpreading((uint64,uint64))void"
    bytec_3 // method "testNestedObjects(((uint64,uint64),(uint64,uint64)))void"
    pushbytes 0x2f670a55 // method "testMethodSelector()void"
    pushbytes 0xd4c81f5b // method "testAssertMatch(uint64)void"
    pushbytes 0xf4835c23 // method "testArc4Encoding((uint64,uint64))void"
    bytec 4 // method "getPlugin(string)(uint64,uint64,uint64,bool,(byte[4],uint64,uint64)[])"
    pushbytes 0x007a4cb0 // method "getMain()(uint64,uint64,uint64,bool,(byte[4],uint64,uint64)[])"
    pushbytes 0xa9bc61f1 // method "setPlugin(string)void"
    uncover 11
    match main_testVectorCreationAndEquality_route@4 main_addVectors_route@5 main_mutateVector_route@6 main_implicitCastingAndSpreading_route@7 main_testNestedObjects_route@8 main_testMethodSelector_route@9 main_testAssertMatch_route@10 main_testArc4Encoding_route@11 main_getPlugin_route@12 main_getMain_route@13 main_setPlugin_route@14
    b main_switch_case_next@15

main_switch_case_next@15:
    b main_after_if_else@17

main_after_if_else@17:
    b main_after_if_else@19

main_after_if_else@19:
    // tests/approvals/mutable-object.algo.ts:12
    // export class MutableObjectDemo extends Contract {
    err

main_setPlugin_route@14:
    // tests/approvals/mutable-object.algo.ts:123
    // public setPlugin(key: string) {
    callsub setPlugin
    b main_switch_case_next@15

main_getMain_route@13:
    // tests/approvals/mutable-object.algo.ts:113
    // public getMain() {
    callsub getMain
    b main_switch_case_next@15

main_getPlugin_route@12:
    // tests/approvals/mutable-object.algo.ts:107
    // public getPlugin(key: string): PluginInfo {
    callsub getPlugin
    b main_switch_case_next@15

main_testArc4Encoding_route@11:
    // tests/approvals/mutable-object.algo.ts:92
    // testArc4Encoding(p: Point) {
    callsub testArc4Encoding
    b main_switch_case_next@15

main_testAssertMatch_route@10:
    // tests/approvals/mutable-object.algo.ts:75
    // testAssertMatch(x: uint64) {
    callsub testAssertMatch
    b main_switch_case_next@15

main_testMethodSelector_route@9:
    // tests/approvals/mutable-object.algo.ts:60
    // public testMethodSelector() {
    callsub testMethodSelector
    b main_switch_case_next@15

main_testNestedObjects_route@8:
    // tests/approvals/mutable-object.algo.ts:49
    // public testNestedObjects(vp: VectorPoint) {
    callsub testNestedObjects
    b main_switch_case_next@15

main_implicitCastingAndSpreading_route@7:
    // tests/approvals/mutable-object.algo.ts:34
    // public implicitCastingAndSpreading(v1: Vector) {
    callsub implicitCastingAndSpreading
    b main_switch_case_next@15

main_mutateVector_route@6:
    // tests/approvals/mutable-object.algo.ts:28
    // public mutateVector(v1: Vector, newX: uint64, newY: uint64): Vector {
    callsub mutateVector
    b main_switch_case_next@15

main_addVectors_route@5:
    // tests/approvals/mutable-object.algo.ts:21
    // public addVectors(v1: Vector, v2: Vector): Vector {
    callsub addVectors
    b main_switch_case_next@15

main_testVectorCreationAndEquality_route@4:
    // tests/approvals/mutable-object.algo.ts:13
    // public testVectorCreationAndEquality() {
    callsub testVectorCreationAndEquality
    b main_switch_case_next@15

main_create_NoOp@16:
    b main_after_if_else@17

main___algots__.defaultCreate@18:
    // tests/approvals/mutable-object.algo.ts:12
    // export class MutableObjectDemo extends Contract {
    txn OnCompletion
    intc_1 // NoOp
    ==
    txn ApplicationID
    intc_1 // 0
    ==
    &&
    assert
    callsub __algots__.defaultCreate
    intc_3 // 1
    return


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testVectorCreationAndEquality[routing]() -> void:
testVectorCreationAndEquality:
    b testVectorCreationAndEquality_block@0

testVectorCreationAndEquality_block@0:
    // tests/approvals/mutable-object.algo.ts:13
    // public testVectorCreationAndEquality() {
    callsub tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testVectorCreationAndEquality
    intc_3 // 1
    return


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.addVectors[routing]() -> void:
addVectors:
    b addVectors_block@0

addVectors_block@0:
    // tests/approvals/mutable-object.algo.ts:21
    // public addVectors(v1: Vector, v2: Vector): Vector {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 16
    ==
    assert // invalid number of bytes for tests/approvals/mutable-object.algo.ts::Vector
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 16
    ==
    assert // invalid number of bytes for tests/approvals/mutable-object.algo.ts::Vector
    callsub tests/approvals/mutable-object.algo.ts::MutableObjectDemo.addVectors
    bytec_1 // 0x151f7c75
    uncover 1
    concat
    log
    intc_3 // 1
    return


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.mutateVector[routing]() -> void:
mutateVector:
    b mutateVector_block@0

mutateVector_block@0:
    // tests/approvals/mutable-object.algo.ts:28
    // public mutateVector(v1: Vector, newX: uint64, newY: uint64): Vector {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 16
    ==
    assert // invalid number of bytes for tests/approvals/mutable-object.algo.ts::Vector
    txna ApplicationArgs 2
    dup
    len
    intc_0 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_0 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    uncover 2
    uncover 2
    uncover 2
    callsub tests/approvals/mutable-object.algo.ts::MutableObjectDemo.mutateVector
    bytec_1 // 0x151f7c75
    uncover 1
    concat
    log
    intc_3 // 1
    return


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.implicitCastingAndSpreading[routing]() -> void:
implicitCastingAndSpreading:
    b implicitCastingAndSpreading_block@0

implicitCastingAndSpreading_block@0:
    // tests/approvals/mutable-object.algo.ts:34
    // public implicitCastingAndSpreading(v1: Vector) {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 16
    ==
    assert // invalid number of bytes for tests/approvals/mutable-object.algo.ts::Vector
    callsub tests/approvals/mutable-object.algo.ts::MutableObjectDemo.implicitCastingAndSpreading
    intc_3 // 1
    return


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testNestedObjects[routing]() -> void:
testNestedObjects:
    b testNestedObjects_block@0

testNestedObjects_block@0:
    // tests/approvals/mutable-object.algo.ts:49
    // public testNestedObjects(vp: VectorPoint) {
    txna ApplicationArgs 1
    dup
    len
    pushint 32
    ==
    assert // invalid number of bytes for tests/approvals/mutable-object.algo.ts::VectorPoint
    callsub tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testNestedObjects
    intc_3 // 1
    return


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testMethodSelector[routing]() -> void:
testMethodSelector:
    b testMethodSelector_block@0

testMethodSelector_block@0:
    // tests/approvals/mutable-object.algo.ts:60
    // public testMethodSelector() {
    callsub tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testMethodSelector
    intc_3 // 1
    return


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testAssertMatch[routing]() -> void:
testAssertMatch:
    b testAssertMatch_block@0

testAssertMatch_block@0:
    // tests/approvals/mutable-object.algo.ts:75
    // testAssertMatch(x: uint64) {
    txna ApplicationArgs 1
    dup
    len
    intc_0 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    callsub tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testAssertMatch
    intc_3 // 1
    return


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testArc4Encoding[routing]() -> void:
testArc4Encoding:
    b testArc4Encoding_block@0

testArc4Encoding_block@0:
    // tests/approvals/mutable-object.algo.ts:92
    // testArc4Encoding(p: Point) {
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 16
    ==
    assert // invalid number of bytes for tests/approvals/mutable-object.algo.ts::Point
    callsub tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testArc4Encoding
    intc_3 // 1
    return


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.getPlugin[routing]() -> void:
getPlugin:
    b getPlugin_block@0

getPlugin_block@0:
    // tests/approvals/mutable-object.algo.ts:107
    // public getPlugin(key: string): PluginInfo {
    txna ApplicationArgs 1
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 1
    *
    pushint 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    callsub tests/approvals/mutable-object.algo.ts::MutableObjectDemo.getPlugin
    bytec_1 // 0x151f7c75
    uncover 1
    concat
    log
    intc_3 // 1
    return


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.getMain[routing]() -> void:
getMain:
    b getMain_block@0

getMain_block@0:
    // tests/approvals/mutable-object.algo.ts:113
    // public getMain() {
    callsub tests/approvals/mutable-object.algo.ts::MutableObjectDemo.getMain
    bytec_1 // 0x151f7c75
    uncover 1
    concat
    log
    intc_3 // 1
    return


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.setPlugin[routing]() -> void:
setPlugin:
    b setPlugin_block@0

setPlugin_block@0:
    // tests/approvals/mutable-object.algo.ts:123
    // public setPlugin(key: string) {
    txna ApplicationArgs 1
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 1
    *
    pushint 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    callsub tests/approvals/mutable-object.algo.ts::MutableObjectDemo.setPlugin
    intc_3 // 1
    return


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testVectorCreationAndEquality() -> void:
tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testVectorCreationAndEquality:
    b tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testVectorCreationAndEquality_block@0

tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testVectorCreationAndEquality_block@0:
    // tests/approvals/mutable-object.algo.ts:14
    // const v1: Vector = { y: 1, x: 0 }
    intc_1 // 0
    itob
    bytec_0 // 0x
    uncover 1
    concat
    intc_3 // 1
    itob
    concat
    // tests/approvals/mutable-object.algo.ts:15
    // log(v1.x)
    dup
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    itob
    log
    // tests/approvals/mutable-object.algo.ts:16
    // log(v1.y)
    dup
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    itob
    log
    // tests/approvals/mutable-object.algo.ts:17
    // const v2: Vector = { y: 1, x: 0 }
    intc_1 // 0
    itob
    bytec_0 // 0x
    uncover 1
    concat
    intc_3 // 1
    itob
    concat
    // tests/approvals/mutable-object.algo.ts:18
    // assertMatch(v1, v2)
    dig 1
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    cover 1
    dup
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    uncover 2
    ==
    cover 2
    uncover 1
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    uncover 1
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    ==
    &&
    assert // assert target is match for conditions
    retsub


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.addVectors(v1: bytes, v2: bytes) -> bytes:
tests/approvals/mutable-object.algo.ts::MutableObjectDemo.addVectors:
    // tests/approvals/mutable-object.algo.ts:21
    // public addVectors(v1: Vector, v2: Vector): Vector {
    proto 2 1
    b tests/approvals/mutable-object.algo.ts::MutableObjectDemo.addVectors_block@0

tests/approvals/mutable-object.algo.ts::MutableObjectDemo.addVectors_block@0:
    // tests/approvals/mutable-object.algo.ts:23
    // x: v1.x + v2.x,
    frame_dig -2
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    frame_dig -1
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    +
    // tests/approvals/mutable-object.algo.ts:24
    // y: v1.y + v2.y,
    frame_dig -2
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    frame_dig -1
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    +
    // tests/approvals/mutable-object.algo.ts:22-25
    // return {
    //   x: v1.x + v2.x,
    //   y: v1.y + v2.y,
    // }
    uncover 1
    itob
    bytec_0 // 0x
    uncover 1
    concat
    uncover 1
    itob
    concat
    retsub


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.mutateVector(v1: bytes, newX: uint64, newY: uint64) -> bytes:
tests/approvals/mutable-object.algo.ts::MutableObjectDemo.mutateVector:
    // tests/approvals/mutable-object.algo.ts:28
    // public mutateVector(v1: Vector, newX: uint64, newY: uint64): Vector {
    proto 3 1
    b tests/approvals/mutable-object.algo.ts::MutableObjectDemo.mutateVector_block@0

tests/approvals/mutable-object.algo.ts::MutableObjectDemo.mutateVector_block@0:
    // tests/approvals/mutable-object.algo.ts:29
    // v1.x = newX
    frame_dig -2
    itob
    frame_dig -3
    intc_1 // 0
    uncover 2
    replace3
    frame_bury -3
    // tests/approvals/mutable-object.algo.ts:30
    // v1.y = newY
    frame_dig -1
    itob
    frame_dig -3
    intc_0 // 8
    uncover 2
    replace3
    dup
    frame_bury -3
    // tests/approvals/mutable-object.algo.ts:31
    // return v1
    retsub


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.implicitCastingAndSpreading(v1: bytes) -> void:
tests/approvals/mutable-object.algo.ts::MutableObjectDemo.implicitCastingAndSpreading:
    // tests/approvals/mutable-object.algo.ts:34
    // public implicitCastingAndSpreading(v1: Vector) {
    proto 1 0
    b tests/approvals/mutable-object.algo.ts::MutableObjectDemo.implicitCastingAndSpreading_block@0

tests/approvals/mutable-object.algo.ts::MutableObjectDemo.implicitCastingAndSpreading_block@0:
    // tests/approvals/mutable-object.algo.ts:35
    // const v2 = clone(v1)
    frame_dig -1
    // tests/approvals/mutable-object.algo.ts:36
    // const v3 = { ...v2 }
    dup
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    cover 1
    dup
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    uncover 2
    itob
    bytec_0 // 0x
    uncover 1
    concat
    uncover 1
    itob
    concat
    cover 1
    // tests/approvals/mutable-object.algo.ts:37
    // assert(v1.x === v2.x)
    frame_dig -1
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    dig 1
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    ==
    assert
    // tests/approvals/mutable-object.algo.ts:38
    // assert(v1.y === v2.y)
    frame_dig -1
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    dig 1
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    ==
    assert
    // tests/approvals/mutable-object.algo.ts:39
    // assertMatch(v1, v2)
    frame_dig -1
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    dig 1
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    ==
    cover 1
    frame_dig -1
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    uncover 1
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    ==
    &&
    assert // assert target is match for conditions
    // tests/approvals/mutable-object.algo.ts:40
    // assert(v3.x === v1.x)
    dup
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    frame_dig -1
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    ==
    assert
    // tests/approvals/mutable-object.algo.ts:41
    // assert(v3.y === v1.y)
    dup
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    frame_dig -1
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    ==
    assert
    // tests/approvals/mutable-object.algo.ts:42
    // assertMatch(v3, v1)
    dup
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    frame_dig -1
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    ==
    cover 1
    dup
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    frame_dig -1
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    ==
    uncover 2
    &&
    assert // assert target is match for conditions
    // tests/approvals/mutable-object.algo.ts:44
    // const { x, y } = v3
    dup
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    cover 1
    dup
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    uncover 2
    cover 1
    cover 2
    // tests/approvals/mutable-object.algo.ts:45
    // assert(x === v3.x)
    dig 1
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    ==
    assert
    // tests/approvals/mutable-object.algo.ts:46
    // assert(y === v3.y)
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    ==
    assert
    retsub


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testNestedObjects(vp: bytes) -> void:
tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testNestedObjects:
    // tests/approvals/mutable-object.algo.ts:49
    // public testNestedObjects(vp: VectorPoint) {
    proto 1 0
    b tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testNestedObjects_block@0

tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testNestedObjects_block@0:
    // tests/approvals/mutable-object.algo.ts:50
    // const v1 = { x: vp.v.x, y: vp.v.y }
    frame_dig -1
    intc_1 // 0
    intc_2 // 16
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    frame_dig -1
    intc_1 // 0
    intc_2 // 16
    extract3
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    uncover 1
    itob
    bytec_0 // 0x
    uncover 1
    concat
    uncover 1
    itob
    concat
    // tests/approvals/mutable-object.algo.ts:51
    // const p1 = { x: vp.p.x, y: vp.p.y }
    frame_dig -1
    intc_2 // 16
    intc_2 // 16
    extract3
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    frame_dig -1
    intc_2 // 16
    intc_2 // 16
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    uncover 1
    itob
    bytec_0 // 0x
    uncover 1
    concat
    uncover 1
    itob
    concat
    // tests/approvals/mutable-object.algo.ts:52
    // const vp1 = { v: clone(v1), p: clone(p1) }
    bytec_0 // 0x
    uncover 2
    concat
    uncover 1
    concat
    // tests/approvals/mutable-object.algo.ts:53
    // log(vp1.v.x)
    dup
    intc_1 // 0
    intc_2 // 16
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    itob
    log
    // tests/approvals/mutable-object.algo.ts:54
    // log(vp1.v.y)
    dup
    intc_1 // 0
    intc_2 // 16
    extract3
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    itob
    log
    // tests/approvals/mutable-object.algo.ts:55
    // log(vp1.p.x)
    dup
    intc_2 // 16
    intc_2 // 16
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    itob
    log
    // tests/approvals/mutable-object.algo.ts:56
    // log(vp1.p.y)
    dup
    intc_2 // 16
    intc_2 // 16
    extract3
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    itob
    log
    // tests/approvals/mutable-object.algo.ts:57
    // assertMatch(vp1, vp)
    dup
    intc_1 // 0
    intc_2 // 16
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    frame_dig -1
    intc_1 // 0
    intc_2 // 16
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    ==
    cover 1
    dup
    intc_1 // 0
    intc_2 // 16
    extract3
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    frame_dig -1
    intc_1 // 0
    intc_2 // 16
    extract3
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    ==
    uncover 2
    &&
    cover 1
    dup
    intc_2 // 16
    intc_2 // 16
    extract3
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    frame_dig -1
    intc_2 // 16
    intc_2 // 16
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    ==
    cover 1
    intc_2 // 16
    intc_2 // 16
    extract3
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    frame_dig -1
    intc_2 // 16
    intc_2 // 16
    extract3
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    ==
    &&
    &&
    assert // assert target is match for conditions
    retsub


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testMethodSelector() -> void:
tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testMethodSelector:
    b tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testMethodSelector_block@0

tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testMethodSelector_block@0:
    // tests/approvals/mutable-object.algo.ts:62
    // methodSelector(MutableObjectDemo.prototype.mutateVector) ===
    bytec_2 // method "mutateVector((uint64,uint64),uint64,uint64)(uint64,uint64)"
    // tests/approvals/mutable-object.algo.ts:63
    // methodSelector('mutateVector((uint64,uint64),uint64,uint64)(uint64,uint64)'),
    bytec_2 // method "mutateVector((uint64,uint64),uint64,uint64)(uint64,uint64)"
    // tests/approvals/mutable-object.algo.ts:62-63
    // methodSelector(MutableObjectDemo.prototype.mutateVector) ===
    //   methodSelector('mutateVector((uint64,uint64),uint64,uint64)(uint64,uint64)'),
    ==
    // tests/approvals/mutable-object.algo.ts:61-64
    // assert(
    //   methodSelector(MutableObjectDemo.prototype.mutateVector) ===
    //     methodSelector('mutateVector((uint64,uint64),uint64,uint64)(uint64,uint64)'),
    // )
    assert
    // tests/approvals/mutable-object.algo.ts:66
    // methodSelector(MutableObjectDemo.prototype.getPlugin) ===
    bytec 4 // method "getPlugin(string)(uint64,uint64,uint64,bool,(byte[4],uint64,uint64)[])"
    // tests/approvals/mutable-object.algo.ts:67
    // methodSelector('getPlugin(string)(uint64,uint64,uint64,bool,(byte[4],uint64,uint64)[])'),
    bytec 4 // method "getPlugin(string)(uint64,uint64,uint64,bool,(byte[4],uint64,uint64)[])"
    // tests/approvals/mutable-object.algo.ts:66-67
    // methodSelector(MutableObjectDemo.prototype.getPlugin) ===
    //   methodSelector('getPlugin(string)(uint64,uint64,uint64,bool,(byte[4],uint64,uint64)[])'),
    ==
    // tests/approvals/mutable-object.algo.ts:65-68
    // assert(
    //   methodSelector(MutableObjectDemo.prototype.getPlugin) ===
    //     methodSelector('getPlugin(string)(uint64,uint64,uint64,bool,(byte[4],uint64,uint64)[])'),
    // )
    assert
    // tests/approvals/mutable-object.algo.ts:70
    // methodSelector(MutableObjectDemo.prototype.testNestedObjects) ===
    bytec_3 // method "testNestedObjects(((uint64,uint64),(uint64,uint64)))void"
    // tests/approvals/mutable-object.algo.ts:71
    // methodSelector('testNestedObjects(((uint64,uint64),(uint64,uint64)))void'),
    bytec_3 // method "testNestedObjects(((uint64,uint64),(uint64,uint64)))void"
    // tests/approvals/mutable-object.algo.ts:70-71
    // methodSelector(MutableObjectDemo.prototype.testNestedObjects) ===
    //   methodSelector('testNestedObjects(((uint64,uint64),(uint64,uint64)))void'),
    ==
    // tests/approvals/mutable-object.algo.ts:69-72
    // assert(
    //   methodSelector(MutableObjectDemo.prototype.testNestedObjects) ===
    //     methodSelector('testNestedObjects(((uint64,uint64),(uint64,uint64)))void'),
    // )
    assert
    retsub


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testAssertMatch(x: uint64) -> void:
tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testAssertMatch:
    // tests/approvals/mutable-object.algo.ts:75
    // testAssertMatch(x: uint64) {
    proto 1 0
    b tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testAssertMatch_block@0

tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testAssertMatch_block@0:
    // tests/approvals/mutable-object.algo.ts:78
    // y: (b = x * 2),
    frame_dig -1
    pushint 2
    *
    // tests/approvals/mutable-object.algo.ts:77-80
    // const obj: Vector = {
    //   y: (b = x * 2),
    //   x: b,
    // }
    dup
    itob
    bytec_0 // 0x
    uncover 1
    concat
    uncover 1
    itob
    concat
    // tests/approvals/mutable-object.algo.ts:81-84
    // assertMatch(obj, {
    //   y: x * 2,
    //   x: x * 2,
    // })
    dup
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    // tests/approvals/mutable-object.algo.ts:82
    // y: x * 2,
    frame_dig -1
    pushint 2
    *
    // tests/approvals/mutable-object.algo.ts:81-84
    // assertMatch(obj, {
    //   y: x * 2,
    //   x: x * 2,
    // })
    ==
    cover 1
    dup
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    // tests/approvals/mutable-object.algo.ts:83
    // x: x * 2,
    frame_dig -1
    pushint 2
    *
    // tests/approvals/mutable-object.algo.ts:81-84
    // assertMatch(obj, {
    //   y: x * 2,
    //   x: x * 2,
    // })
    ==
    uncover 2
    &&
    assert // assert target is match for conditions
    // tests/approvals/mutable-object.algo.ts:85
    // const v = { y: obj.y, x: obj.x }
    dup
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    cover 1
    dup
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    uncover 2
    itob
    bytec_0 // 0x
    uncover 1
    concat
    uncover 1
    itob
    concat
    // tests/approvals/mutable-object.algo.ts:87
    // assertMatch(obj, { x: v.x, y: v.y })
    dig 1
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    cover 1
    dup
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    uncover 2
    ==
    cover 2
    dig 1
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    uncover 1
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    ==
    uncover 2
    &&
    assert // assert target is match for conditions
    // tests/approvals/mutable-object.algo.ts:88
    // assertMatch(obj, { y: { greaterThan: x } })
    dup
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    frame_dig -1
    >
    assert // assert target is match for conditions
    // tests/approvals/mutable-object.algo.ts:89
    // assertMatch(obj, { x: { greaterThan: x } })
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    frame_dig -1
    >
    assert // assert target is match for conditions
    retsub


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testArc4Encoding(p: bytes) -> void:
tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testArc4Encoding:
    // tests/approvals/mutable-object.algo.ts:92
    // testArc4Encoding(p: Point) {
    proto 1 0
    b tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testArc4Encoding_block@0

tests/approvals/mutable-object.algo.ts::MutableObjectDemo.testArc4Encoding_block@0:
    // tests/approvals/mutable-object.algo.ts:93
    // assert(p.x !== p.y, 'For the purpose of this test, a should not equal b')
    frame_dig -1
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    frame_dig -1
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    !=
    assert // For the purpose of this test, a should not equal b
    // tests/approvals/mutable-object.algo.ts:95
    // x: p.x,
    frame_dig -1
    intc_0 // 8
    intc_0 // 8
    extract3
    btoi
    // tests/approvals/mutable-object.algo.ts:96
    // y: p.y,
    frame_dig -1
    intc_1 // 0
    intc_0 // 8
    extract3
    btoi
    // tests/approvals/mutable-object.algo.ts:94-97
    // const obj: Vector = {
    //   x: p.x,
    //   y: p.y,
    // }
    uncover 1
    itob
    bytec_0 // 0x
    uncover 1
    concat
    uncover 1
    itob
    concat
    // tests/approvals/mutable-object.algo.ts:98
    // const pEncoded = encodeArc4(p)
    frame_dig -1
    cover 1
    // tests/approvals/mutable-object.algo.ts:100
    // assert(pEncoded === objEncoded.slice(8).concat(objEncoded.slice(0, 8)), 'Encoded order should be swapped')
    dup
    len
    intc_0 // 8
    dig 1
    >=
    intc_0 // 8
    dig 2
    uncover 2
    select
    dig 2
    uncover 1
    uncover 2
    substring3
    cover 1
    dup
    len
    intc_1 // 0
    dig 1
    >=
    intc_1 // 0
    dig 2
    uncover 2
    select
    cover 1
    intc_0 // 8
    dig 1
    >=
    intc_0 // 8
    uncover 2
    uncover 2
    select
    uncover 2
    uncover 2
    uncover 2
    substring3
    concat
    ==
    assert // Encoded order should be swapped
    retsub


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.getPlugin(key: bytes) -> bytes:
tests/approvals/mutable-object.algo.ts::MutableObjectDemo.getPlugin:
    // tests/approvals/mutable-object.algo.ts:107
    // public getPlugin(key: string): PluginInfo {
    proto 1 1
    b tests/approvals/mutable-object.algo.ts::MutableObjectDemo.getPlugin_block@0

tests/approvals/mutable-object.algo.ts::MutableObjectDemo.getPlugin_block@0:
    // tests/approvals/mutable-object.algo.ts:103
    // plugins = BoxMap<string, PluginInfo>({ keyPrefix: 'plugins' })
    bytec 6 // "plugins"
    frame_dig -1
    concat
    // tests/approvals/mutable-object.algo.ts:108
    // const value = clone(this.plugins(key).value)
    box_get
    assert // Box must have value
    // tests/approvals/mutable-object.algo.ts:109
    // assert(value.lastCalled.asUint64() > 0, 'Last called not zero')
    dup
    intc_2 // 16
    intc_0 // 8
    extract3
    btoi
    intc_1 // 0
    >
    assert // Last called not zero
    // tests/approvals/mutable-object.algo.ts:110
    // return value
    retsub


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.getMain() -> bytes:
tests/approvals/mutable-object.algo.ts::MutableObjectDemo.getMain:
    b tests/approvals/mutable-object.algo.ts::MutableObjectDemo.getMain_block@0

tests/approvals/mutable-object.algo.ts::MutableObjectDemo.getMain_block@0:
    // tests/approvals/mutable-object.algo.ts:105
    // plugin = Box<PluginInfo>({ key: 'main' })
    pushbytes "main"
    // tests/approvals/mutable-object.algo.ts:114
    // const value = clone(this.plugin.value)
    box_get
    assert // Box must have value
    // tests/approvals/mutable-object.algo.ts:115
    // assert(value.lastCalled.asUint64() > 0, 'Last called not zero')
    dup
    intc_2 // 16
    intc_0 // 8
    extract3
    btoi
    intc_1 // 0
    >
    assert // Last called not zero
    // tests/approvals/mutable-object.algo.ts:116
    // return value
    retsub


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.setPlugin(key: bytes) -> void:
tests/approvals/mutable-object.algo.ts::MutableObjectDemo.setPlugin:
    // tests/approvals/mutable-object.algo.ts:123
    // public setPlugin(key: string) {
    proto 1 0
    b tests/approvals/mutable-object.algo.ts::MutableObjectDemo.setPlugin_block@0

tests/approvals/mutable-object.algo.ts::MutableObjectDemo.setPlugin_block@0:
    // tests/approvals/mutable-object.algo.ts:128
    // adminPrivileges: new arc4.Bool(false),
    pushbytes 0x00
    intc_1 // 0
    intc_1 // 0
    setbit
    // tests/approvals/mutable-object.algo.ts:131
    // selector: new arc4.StaticBytes(methodSelector('test()void')),
    bytec 7 // method "test()void"
    len
    pushint 4
    ==
    assert // invalid size
    // tests/approvals/mutable-object.algo.ts:124-136
    // this.plugins(key).value = {
    //   lastValidRound: new arc4.Uint64(1),
    //   cooldown: new arc4.Uint64(),
    //   lastCalled: new arc4.Uint64(),
    //   adminPrivileges: new arc4.Bool(false),
    //   methods: [
    //     {
    //       selector: new arc4.StaticBytes(methodSelector('test()void')),
    //       cooldown: new arc4.Uint64(1),
    //       lastCalled: new arc4.Uint64(1),
    //     },
    //   ],
    // }
    bytec_0 // 0x
    // tests/approvals/mutable-object.algo.ts:131
    // selector: new arc4.StaticBytes(methodSelector('test()void')),
    bytec 7 // method "test()void"
    // tests/approvals/mutable-object.algo.ts:124-136
    // this.plugins(key).value = {
    //   lastValidRound: new arc4.Uint64(1),
    //   cooldown: new arc4.Uint64(),
    //   lastCalled: new arc4.Uint64(),
    //   adminPrivileges: new arc4.Bool(false),
    //   methods: [
    //     {
    //       selector: new arc4.StaticBytes(methodSelector('test()void')),
    //       cooldown: new arc4.Uint64(1),
    //       lastCalled: new arc4.Uint64(1),
    //     },
    //   ],
    // }
    concat
    // tests/approvals/mutable-object.algo.ts:132
    // cooldown: new arc4.Uint64(1),
    bytec 5 // 0x0000000000000001
    // tests/approvals/mutable-object.algo.ts:124-136
    // this.plugins(key).value = {
    //   lastValidRound: new arc4.Uint64(1),
    //   cooldown: new arc4.Uint64(),
    //   lastCalled: new arc4.Uint64(),
    //   adminPrivileges: new arc4.Bool(false),
    //   methods: [
    //     {
    //       selector: new arc4.StaticBytes(methodSelector('test()void')),
    //       cooldown: new arc4.Uint64(1),
    //       lastCalled: new arc4.Uint64(1),
    //     },
    //   ],
    // }
    concat
    // tests/approvals/mutable-object.algo.ts:133
    // lastCalled: new arc4.Uint64(1),
    bytec 5 // 0x0000000000000001
    // tests/approvals/mutable-object.algo.ts:124-136
    // this.plugins(key).value = {
    //   lastValidRound: new arc4.Uint64(1),
    //   cooldown: new arc4.Uint64(),
    //   lastCalled: new arc4.Uint64(),
    //   adminPrivileges: new arc4.Bool(false),
    //   methods: [
    //     {
    //       selector: new arc4.StaticBytes(methodSelector('test()void')),
    //       cooldown: new arc4.Uint64(1),
    //       lastCalled: new arc4.Uint64(1),
    //     },
    //   ],
    // }
    concat
    intc_3 // 1
    itob
    extract 6 2
    uncover 1
    concat
    bytec_0 // 0x
    // tests/approvals/mutable-object.algo.ts:125
    // lastValidRound: new arc4.Uint64(1),
    bytec 5 // 0x0000000000000001
    // tests/approvals/mutable-object.algo.ts:124-136
    // this.plugins(key).value = {
    //   lastValidRound: new arc4.Uint64(1),
    //   cooldown: new arc4.Uint64(),
    //   lastCalled: new arc4.Uint64(),
    //   adminPrivileges: new arc4.Bool(false),
    //   methods: [
    //     {
    //       selector: new arc4.StaticBytes(methodSelector('test()void')),
    //       cooldown: new arc4.Uint64(1),
    //       lastCalled: new arc4.Uint64(1),
    //     },
    //   ],
    // }
    concat
    // tests/approvals/mutable-object.algo.ts:126
    // cooldown: new arc4.Uint64(),
    bytec 8 // 0x0000000000000000
    // tests/approvals/mutable-object.algo.ts:124-136
    // this.plugins(key).value = {
    //   lastValidRound: new arc4.Uint64(1),
    //   cooldown: new arc4.Uint64(),
    //   lastCalled: new arc4.Uint64(),
    //   adminPrivileges: new arc4.Bool(false),
    //   methods: [
    //     {
    //       selector: new arc4.StaticBytes(methodSelector('test()void')),
    //       cooldown: new arc4.Uint64(1),
    //       lastCalled: new arc4.Uint64(1),
    //     },
    //   ],
    // }
    concat
    // tests/approvals/mutable-object.algo.ts:127
    // lastCalled: new arc4.Uint64(),
    bytec 8 // 0x0000000000000000
    // tests/approvals/mutable-object.algo.ts:124-136
    // this.plugins(key).value = {
    //   lastValidRound: new arc4.Uint64(1),
    //   cooldown: new arc4.Uint64(),
    //   lastCalled: new arc4.Uint64(),
    //   adminPrivileges: new arc4.Bool(false),
    //   methods: [
    //     {
    //       selector: new arc4.StaticBytes(methodSelector('test()void')),
    //       cooldown: new arc4.Uint64(1),
    //       lastCalled: new arc4.Uint64(1),
    //     },
    //   ],
    // }
    concat
    uncover 2
    concat
    pushint 27
    itob
    extract 6 2
    concat
    uncover 1
    concat
    // tests/approvals/mutable-object.algo.ts:103
    // plugins = BoxMap<string, PluginInfo>({ keyPrefix: 'plugins' })
    bytec 6 // "plugins"
    frame_dig -1
    concat
    // tests/approvals/mutable-object.algo.ts:124-136
    // this.plugins(key).value = {
    //   lastValidRound: new arc4.Uint64(1),
    //   cooldown: new arc4.Uint64(),
    //   lastCalled: new arc4.Uint64(),
    //   adminPrivileges: new arc4.Bool(false),
    //   methods: [
    //     {
    //       selector: new arc4.StaticBytes(methodSelector('test()void')),
    //       cooldown: new arc4.Uint64(1),
    //       lastCalled: new arc4.Uint64(1),
    //     },
    //   ],
    // }
    dup
    box_del
    pop
    uncover 1
    box_put
    retsub


// tests/approvals/mutable-object.algo.ts::MutableObjectDemo.__algots__.defaultCreate() -> void:
__algots__.defaultCreate:
    b __algots__.defaultCreate_block@0

__algots__.defaultCreate_block@0:
    retsub
