contract MutableObjectDemo
{
  boxes {
    ["plugins"]: string => tests/approvals/mutable-object.algo.ts::PluginInfo
    ["main"]: tests/approvals/mutable-object.algo.ts::PluginInfo
  }
  approvalProgram(): bool
  {
    return arc4Router()
  }
  
  clearProgram(): bool
  {
    return True
  }
  
  testVectorCreationAndEquality(): void
  {
    v1: tests/approvals/mutable-object.algo.ts::Vector = new tests/approvals/mutable-object.algo.ts::Vector(x=($0 = #{ y: ($1 = #{ y: 1, x: 0 }).y, x: $1.x }).x, y=$0.y)
    log(itob(v1.x))
    log(itob(v1.y))
    v2: tests/approvals/mutable-object.algo.ts::Vector = new tests/approvals/mutable-object.algo.ts::Vector(x=($2 = #{ y: ($3 = #{ y: 1, x: 0 }).y, x: $3.x }).x, y=$2.y)
    assert(v1.x == v2.x and v1.y == v2.y, comment=assert target is match for conditions)
  }
  
  addVectors(v1: tests/approvals/mutable-object.algo.ts::Vector, v2: tests/approvals/mutable-object.algo.ts::Vector): tests/approvals/mutable-object.algo.ts::Vector
  {
    return new tests/approvals/mutable-object.algo.ts::Vector(x=v1.x + v2.x, y=v1.y + v2.y)
  }
  
  mutateVector(v1: tests/approvals/mutable-object.algo.ts::Vector, newX: uint64, newY: uint64): tests/approvals/mutable-object.algo.ts::Vector
  {
    v1.x: uint64 = newX
    v1.y: uint64 = newY
    return v1
  }
  
  implicitCastingAndSpreading(v1: tests/approvals/mutable-object.algo.ts::Vector): void
  {
    v2: tests/approvals/mutable-object.algo.ts::Vector = copy(v1)
    v3: object = new object(x=($4 = #{ x: v2.x, y: v2.y }).x, y=$4.y)
    assert(v1.x == v2.x)
    assert(v1.y == v2.y)
    assert(v1.x == v2.x and v1.y == v2.y, comment=assert target is match for conditions)
    assert(v3.x == v1.x)
    assert(v3.y == v1.y)
    assert(v3.x == v1.x and v3.y == v1.y, comment=assert target is match for conditions)
    #[x, y]: readonly [uint64, uint64] = #[v3.x, v3.y]
    assert(x == v3.x)
    assert(y == v3.y)
  }
  
  testNestedObjects(vp: tests/approvals/mutable-object.algo.ts::VectorPoint): void
  {
    v1: object = new object(x=($5 = #{ x: vp.v.x, y: vp.v.y }).x, y=$5.y)
    p1: object = new object(x=($6 = #{ x: vp.p.x, y: vp.p.y }).x, y=$6.y)
    vp1: object = new object(v=($7 = #{ v: copy(v1), p: copy(p1) }).v, p=$7.p)
    log(itob(vp1.v.x))
    log(itob(vp1.v.y))
    log(itob(vp1.p.x))
    log(itob(vp1.p.y))
    assert(vp1.v.x == vp.v.x and vp1.v.y == vp.v.y and vp1.p.y == vp.p.y and vp1.p.x == vp.p.x, comment=assert target is match for conditions)
  }
  
  testMethodSelector(): void
  {
    assert(Method("mutateVector((uint64,uint64),uint64,uint64)(uint64,uint64)") == Method("mutateVector((uint64,uint64),uint64,uint64)(uint64,uint64)"))
    assert(Method("getPlugin(string)(uint64,uint64,uint64,bool,(byte[4],uint64,uint64)[])") == Method("getPlugin(string)(uint64,uint64,uint64,bool)"))
    assert(Method("testNestedObjects(((uint64,uint64),(uint64,uint64)))void") == Method("testNestedObjects(((uint64,uint64),(uint64,uint64)))void"))
  }
  
  testAssertMatch(x: uint64): void
  {
    obj: tests/approvals/mutable-object.algo.ts::Vector = new tests/approvals/mutable-object.algo.ts::Vector(x=($8 = #{ y: (b = x * 2), x: b }).x, y=$8.y)
    assert(obj.y == x * 2 and obj.x == x * 2, comment=assert target is match for conditions)
    v: object = new object(y=($9 = #{ y: obj.y, x: obj.x }).y, x=$9.x)
    assert(obj.x == v.x and obj.y == v.y, comment=assert target is match for conditions)
    assert(obj.y > x, comment=assert target is match for conditions)
    assert(obj.x > x, comment=assert target is match for conditions)
  }
  
  testArc4Encoding(p: tests/approvals/mutable-object.algo.ts::Point): void
  {
    assert(p.x != p.y, comment=For the purpose of this test, a should not equal b)
    obj: tests/approvals/mutable-object.algo.ts::Vector = new tests/approvals/mutable-object.algo.ts::Vector(x=($10 = #{ x: p.x, y: p.y }).x, y=$10.y)
    pEncoded: bytes = reinterpret_cast<bytes>(ARC4_ENCODE(p, wtype=Point))
    objEncoded: bytes = reinterpret_cast<bytes>(ARC4_ENCODE(obj, wtype=Vector))
    assert(pEncoded == concat(objEncoded.slice(8), objEncoded.slice(0, 8)), comment=Encoded order should be swapped)
  }
  
  getPlugin(key: string): tests/approvals/mutable-object.algo.ts::PluginInfo
  {
    value: tests/approvals/mutable-object.algo.ts::PluginInfo = copy(Box[BoxMapKey(prefix="plugins", key=key)].value)
    assert(ARC4_DECODE(value.lastCalled) > 0, comment=Last called not zero)
    return value
  }
  
  getMain(): tests/approvals/mutable-object.algo.ts::PluginInfo
  {
    value: tests/approvals/mutable-object.algo.ts::PluginInfo = copy(Box["main"].value)
    assert(ARC4_DECODE(value.lastCalled) > 0, comment=Last called not zero)
    return value
  }
  
  setPlugin(key: string): void
  {
    Box[BoxMapKey(prefix="plugins", key=key)].value: tests/approvals/mutable-object.algo.ts::PluginInfo = new tests/approvals/mutable-object.algo.ts::PluginInfo(lastValidRound=($11 = #{ lastValidRound: 1, cooldown: 0, lastCalled: 0, adminPrivileges: False, methods: #[#{ selector: ARC4_ENCODE(reinterpret_cast<bytes>(Method("test()void")), wtype=arc4.static_array<arc4.byte>), cooldown: 1, lastCalled: 1 }] }).lastValidRound, cooldown=$11.cooldown, lastCalled=$11.lastCalled, adminPrivileges=$11.adminPrivileges, methods=new arc4.dynamic_array<tests/approvals/mutable-object.algo.ts::MethodInfo>(new tests/approvals/mutable-object.algo.ts::MethodInfo(selector=($12 = ($13 = $11.methods).0).selector, cooldown=$12.cooldown, lastCalled=$12.lastCalled)))
  }
  
  __algots__.defaultCreate(): void
  {
  }
  
}