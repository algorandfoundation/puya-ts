main tests/approvals/property-ordering.algo.ts::Demo.approvalProgram:
    block@0: // L28
        tests/approvals/property-ordering.algo.ts::test_assign_from_literal(4u)
        let aggregate%val_as_bytes%0#1: bytes[8] = (itob 3u)
        let aggregate%as_Encoded(uint64)%0#1: Encoded(uint64) = aggregate%val_as_bytes%0#1
        let aggregate%encoded%0#1: Encoded(uint64) = (concat 0x aggregate%as_Encoded(uint64)%0#1)
        let aggregate%val_as_bytes%1#1: bytes[8] = (itob 4u)
        let aggregate%as_Encoded(uint64)%1#1: Encoded(uint64) = aggregate%val_as_bytes%1#1
        let aggregate%encoded%1#1: Encoded(uint64,uint64) = (concat aggregate%encoded%0#1 aggregate%as_Encoded(uint64)%1#1)
        let aggregate%encoded%2#1: Encoded(uint64,uint64) = (concat aggregate%encoded%1#1 0x)
        let tmp%0#0: Encoded(uint64,uint64) = aggregate%encoded%2#1
        let test_assign_from_var%0#0: Encoded(uint64,uint64) = tests/approvals/property-ordering.algo.ts::test_assign_from_var(tmp%0#0)
        return 1u

subroutine tests/approvals/property-ordering.algo.ts::test_assign_from_var(x: Encoded(uint64,uint64)) -> Encoded(uint64,uint64):
    block@0: // L7
        let x%out#0: Encoded(uint64,uint64) = x#0
        let aggregate%extract%0#1: bytes = (extract3 x#0 0u 8u)
        let tuple_item%0#0: Encoded(uint64) = aggregate%extract%0#1
        let values%0#0: uint64 = (btoi tuple_item%0#0)
        let aggregate%extract%1#1: bytes = (extract3 x#0 8u 8u)
        let tuple_item%1#0: Encoded(uint64) = aggregate%extract%1#1
        let values%1#0: uint64 = (btoi tuple_item%1#0)
        let tmp%0#0: bool = (!= values%0#0 values%1#0)
        (assert tmp%0#0) // For the purpose of this test, a should not equal b
        let aggregate%extract%2#1: bytes = (extract3 x#0 8u 8u)
        let tuple_item%2#0: Encoded(uint64) = aggregate%extract%2#1
        let values%2#0: uint64 = (btoi tuple_item%2#0)
        let aggregate%extract%3#1: bytes = (extract3 x#0 0u 8u)
        let tuple_item%3#0: Encoded(uint64) = aggregate%extract%3#1
        let values%3#0: uint64 = (btoi tuple_item%3#0)
        let aggregate%val_as_bytes%0#1: bytes[8] = (itob values%2#0)
        let aggregate%as_Encoded(uint64)%0#1: Encoded(uint64) = aggregate%val_as_bytes%0#1
        let aggregate%encoded%0#1: Encoded(uint64) = (concat 0x aggregate%as_Encoded(uint64)%0#1)
        let aggregate%val_as_bytes%1#1: bytes[8] = (itob values%3#0)
        let aggregate%as_Encoded(uint64)%1#1: Encoded(uint64) = aggregate%val_as_bytes%1#1
        let aggregate%encoded%1#1: Encoded(uint64,uint64) = (concat aggregate%encoded%0#1 aggregate%as_Encoded(uint64)%1#1)
        let aggregate%encoded%2#1: Encoded(uint64,uint64) = (concat aggregate%encoded%1#1 0x)
        let tmp%1#0: Encoded(uint64,uint64) = aggregate%encoded%2#1
        let obj#0: Encoded(uint64,uint64) = tmp%1#0
        let awst_tmp%0#0: Encoded(uint64,uint64) = x#0
        let xEncoded#0: bytes = awst_tmp%0#0
        let awst_tmp%1#0: Encoded(uint64,uint64) = obj#0
        let objEncoded#0: bytes = awst_tmp%1#0
        let length%0#0: uint64 = (len objEncoded#0)
        let is_out_of_bounds%0#0: bool = (>= 8u length%0#0)
        let bounded_index%0#0: uint64 = (select 8u length%0#0 is_out_of_bounds%0#0)
        let tmp%2#0: bytes = (substring3 objEncoded#0 bounded_index%0#0 length%0#0)
        let length%1#0: uint64 = (len objEncoded#0)
        let is_out_of_bounds%1#0: bool = (>= 0u length%1#0)
        let bounded_index%1#0: uint64 = (select 0u length%1#0 is_out_of_bounds%1#0)
        let is_out_of_bounds%2#0: bool = (>= 8u length%1#0)
        let bounded_index%2#0: uint64 = (select 8u length%1#0 is_out_of_bounds%2#0)
        let tmp%3#0: bytes = (substring3 objEncoded#0 bounded_index%1#0 bounded_index%2#0)
        let tmp%4#0: bytes = (concat tmp%2#0 tmp%3#0)
        let tmp%5#0: bool = (== xEncoded#0 tmp%4#0)
        (assert tmp%5#0) // Encoded order should be swapped
        return x%out#0

subroutine tests/approvals/property-ordering.algo.ts::test_assign_from_literal(x: uint64) -> void:
    block@0: // L15
        let awst_tmp%0#0: uint64 = (* x#0 2u)
        let b#0: uint64 = awst_tmp%0#0
        let aggregate%val_as_bytes%0#1: bytes[8] = (itob b#0)
        let aggregate%as_Encoded(uint64)%0#1: Encoded(uint64) = aggregate%val_as_bytes%0#1
        let aggregate%encoded%0#1: Encoded(uint64) = (concat 0x aggregate%as_Encoded(uint64)%0#1)
        let aggregate%val_as_bytes%1#1: bytes[8] = (itob b#0)
        let aggregate%as_Encoded(uint64)%1#1: Encoded(uint64) = aggregate%val_as_bytes%1#1
        let aggregate%encoded%1#1: Encoded(uint64,uint64) = (concat aggregate%encoded%0#1 aggregate%as_Encoded(uint64)%1#1)
        let aggregate%encoded%2#1: Encoded(uint64,uint64) = (concat aggregate%encoded%1#1 0x)
        let tmp%0#0: Encoded(uint64,uint64) = aggregate%encoded%2#1
        let obj#0: Encoded(uint64,uint64) = tmp%0#0
        let aggregate%extract%0#1: bytes = (extract3 obj#0 8u 8u)
        let tuple_item%0#0: Encoded(uint64) = aggregate%extract%0#1
        let values%0#0: uint64 = (btoi tuple_item%0#0)
        let tmp%1#0: uint64 = (* x#0 2u)
        let tmp%2#0: bool = (== values%0#0 tmp%1#0)
        goto tmp%2#0 ? block@1 : block@3
    block@1: // and_contd_L21
        let aggregate%extract%1#1: bytes = (extract3 obj#0 0u 8u)
        let tuple_item%1#0: Encoded(uint64) = aggregate%extract%1#1
        let values%1#0: uint64 = (btoi tuple_item%1#0)
        let tmp%3#0: uint64 = (* x#0 2u)
        let tmp%4#0: bool = (== values%1#0 tmp%3#0)
        goto tmp%4#0 ? block@2 : block@3
    block@2: // bool_true_L21
        let and_result%0#0: bool = 1u
        goto block@4
    block@3: // bool_false_L21
        let and_result%0#1: bool = 0u
        goto block@4
    block@4: // bool_merge_L21
        let and_result%0#2: bool = Ï†(and_result%0#0 <- block@2, and_result%0#1 <- block@3)
        (assert and_result%0#2) // assert target is match for conditions
        return 