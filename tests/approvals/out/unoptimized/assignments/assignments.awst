subroutine resetCount(): void
{
  stores(0, 0)
}
subroutine getCount(): uint64
{
  return loads(0)
}
subroutine incCount(): void
{
  stores(0, loads(0) + 1)
}
contract AssignmentsAlgo
{
  reservedScratchSpace: [0]
  approvalProgram(): bool
  {
    return arc4Router()
  }
  
  clearProgram(): bool
  {
    return True
  }
  
  testPrimitives(u: uint64): void
  {
    p1: uint64 = u
    p2: uint64 = 2
    p2: uint64 = p2 + 1
    assert(p2 == 3)
    assert(p1 == u)
  }
  
  testArrayDestructure(i_a: arc4.dynamic_array<uint64>, u: uint64, m_a: arc4.dynamic_array<uint64>): void
  {
    #[a1]: readonly [uint64] = #[i_a[1]]
    assert(a1 == i_a[1])
    tests/approvals/assignments.algo.ts::resetCount()
    a5: arc4.tuple<uint64,uint64,uint64> = (#[a2, a3] = #[($0 = #[tests/approvals/assignments.algo.ts::logAndReturn(u), tests/approvals/assignments.algo.ts::logAndReturn(u), tests/approvals/assignments.algo.ts::logAndReturn(u)]).0, $0.1]), ARC4_ENCODE(#[$0.0, $0.1, $0.2], wtype=arc4.tuple<uint64,uint64,uint64>)
    assert(tests/approvals/assignments.algo.ts::getCount() == 3, comment=logAndReturn called 3 times)
    assert(a2 == u)
    assert(a3 == u)
    assert(&&(&&(&&(3 == 3, a5.0 == u), a5.1 == u), a5.2 == u), comment=assert target is match for conditions)
    assert(3 == 3, comment=a5 length should be 3)
    #[a4]: readonly [uint64] = #[($1 = #[1]).0]
    assert(a4 == 1)
    #[c, d]: readonly [uint64, uint64] = #[($2 = #[tests/approvals/assignments.algo.ts::logAndReturn(u), tests/approvals/assignments.algo.ts::logAndReturn(u), tests/approvals/assignments.algo.ts::logAndReturn(u)]).0, $2.1]
    assert(&&(&&(2 == 2, c == u), d == u), comment=assert target is match for conditions)
    #[a6, a7]: readonly [uint64, uint64] = #[m_a[0], m_a[1]]
    assert(a6 == m_a[0])
    assert(a7 == m_a[1])
  }
  
  testArrayNarrowing(m_a: arc4.dynamic_array<uint64>, u: uint64): void
  {
    direct: arc4.dynamic_array<uint64> = copy(m_a)
    m_a[0]: uint64 = m_a[0] + 1
    direct[0]: uint64 = direct[0] + 2
    assert(m_a[0] != direct[0])
    narrowed: arc4.dynamic_array<uint64> = convert_array(copy(m_a), wtype=arc4.dynamic_array<uint64>)
    narrowed2: arc4.dynamic_array<uint64> = narrowed
    result: arc4.dynamic_array<uint64> = (fromLit = new arc4.dynamic_array<uint64>(($3 = #[u, u, u]).0, $3.1, $3.2)), new arc4.dynamic_array<uint64>(($4 = #[u, u, u]).0, $4.1, $4.2)
    fromLit2: arc4.dynamic_array<uint64> = new arc4.dynamic_array<uint64>(($5 = #[u, u, u]).0, $5.1, $5.2)
  }
  
  testTupleToArray(m_t: arc4.tuple<uint64,uint64>, i_t: readonly [uint64, uint64]): void
  {
    m_a: arc4.dynamic_array<uint64> = new arc4.dynamic_array<uint64>(copy(m_t).0, copy(m_t).1)
    assert(&&(&&(m_a.length == 2, m_a[0] == m_t.0), m_a[1] == m_t.1), comment=assert target is match for conditions)
    i_a: arc4.dynamic_array<uint64> = new arc4.dynamic_array<uint64>(copy(m_t).0, copy(m_t).1)
    assert(&&(&&(i_a.length == 2, i_a[0] == m_t.0), i_a[1] == m_t.1), comment=assert target is match for conditions)
    i_a2: arc4.dynamic_array<uint64> = new arc4.dynamic_array<uint64>(i_t.0, i_t.1)
    assert(&&(&&(i_a2.length == 2, i_a2[0] == i_t.0), i_a2[1] == i_t.1), comment=assert target is match for conditions)
  }
  
  testNested(i_a: arc4.dynamic_array<arc4.dynamic_array<uint64>>): void
  {
    #[#[a]]: readonly [readonly [uint64]] = #[#[i_a[0][0]]]
    assert(a == i_a[0][0])
  }
  
  testDestructureObj(m: Object3EB715E7, i: ReadonlyObject3EB715E7{ a: uint64, b: string }): void
  {
    #[a1, b1]: readonly [uint64, string] = #[m.a, m.b]
    #[a2, b2]: readonly [uint64, string] = #[i.a, i.b]
  }
  
  testObjLiteralNarrowing(a: uint64, b: uint64): void
  {
    mObj: tests/approvals/assignments.algo.ts::MutableObj = new tests/approvals/assignments.algo.ts::MutableObj(a=($6 = #{ a: a, b: b }).a, b=$6.b)
    imObj: ImmutableObj{ a: uint64, b: uint64 } = #{ a: ($7 = #{ a: a, b: b }).a, b: $7.b }
    mObj2: tests/approvals/assignments.algo.ts::MutableObj = new tests/approvals/assignments.algo.ts::MutableObj(a=($8 = #{ a: ($9 = #{ a: ($10 = #[123, 456]).0, b: $10.1 }).a, b: $9.b }).a, b=$8.b)
    imObj2: ImmutableObj{ a: uint64, b: uint64 } = #{ a: ($11 = #{ a: ($12 = #{ a: ($13 = #[456, b]).0, b: $13.1 }).a, b: $12.b }).a, b: $11.b }
    tests/approvals/assignments.algo.ts::resetCount()
    mObj3: tests/approvals/assignments.algo.ts::MutableObj = new tests/approvals/assignments.algo.ts::MutableObj(a=($14 = #{ a: ($15 = tests/approvals/assignments.algo.ts::getVal()).a, b: $15.b }).a, b=$14.b)
    assert(tests/approvals/assignments.algo.ts::getCount() == 1, comment=getVal should only be called once)
    mObj4: tests/approvals/assignments.algo.ts::MutableObj = new tests/approvals/assignments.algo.ts::MutableObj(a=($16 = #{ a: ($17 = #{ a: ($18 = #[($19 = tests/approvals/assignments.algo.ts::getVal()).a, $19.b, a, b]).2, b: $18.3 }).a, b: $17.b }).a, b=$16.b)
    assert(tests/approvals/assignments.algo.ts::getCount() == 2, comment=getVal should still be called once even though its result is not used)
  }
  
  testMixed(m: arc4.dynamic_array<Object7CFAF5D6>): void
  {
    #[#[#[a1]]]: readonly [readonly [readonly [uint64]]] = #[#[#[m[0].a.0]]]
    m: arc4.dynamic_array<Object7CFAF5D6> = new arc4.dynamic_array<Object7CFAF5D6>(new Object7CFAF5D6(a=ARC4_ENCODE(#[($20 = ($21 = ($22 = #[#{ a: #[($23 = ($24 = #{ a: ($25 = #[#[213]]).0 }).a).0] }]).0).a).0], wtype=arc4.tuple<uint64>)))
  }
  
  __algots__.defaultCreate(): void
  {
  }
  
}
subroutine getVal(): ImmutableObj{ a: uint64, b: uint64 }
{
  tests/approvals/assignments.algo.ts::incCount()
  return #{ a: ($26 = #{ a: ($27 = #[1, 2]).0, b: $27.1 }).a, b: $26.b }
}
subroutine logAndReturn(u: uint64): uint64
{
  tests/approvals/assignments.algo.ts::incCount()
  log(itob(u))
  return u
}