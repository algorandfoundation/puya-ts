contract ByIndex
{
  approvalProgram(): bool
  {
    return arc4Router()
  }
  
  clearProgram(): bool
  {
    return True
  }
  
  testExplicitIndex(account: account): uint64
  {
    return checked_maybe(acct_params_get<AcctBalance>(account), comment=account funded)
  }
  
  testImplicitValue(account: account): uint64
  {
    return checked_maybe(acct_params_get<AcctBalance>(account), comment=account funded)
  }
  
  __algots__.defaultCreate(): void
  {
  }
  
}
contract ByValue
{
  approvalProgram(): bool
  {
    return arc4Router()
  }
  
  clearProgram(): bool
  {
    return True
  }
  
  testExplicitValue(account: account): uint64
  {
    return checked_maybe(acct_params_get<AcctBalance>(account), comment=account funded)
  }
  
  __algots__.defaultCreate(): void
  {
  }
  
}
contract EchoResource
{
  approvalProgram(): bool
  {
    return arc4Router()
  }
  
  clearProgram(): bool
  {
    return True
  }
  
  echoResourceByIndex(asset: asset, app: application, acc: account): arc4.tuple<asset,application,account>
  {
    assetIdx: uint64 = btoi(txnas<ApplicationArgs>(1))
    assert(asset == txnas<Assets>(assetIdx), comment=expected asset to be passed by Index)
    appIdx: uint64 = btoi(txnas<ApplicationArgs>(2))
    assert(app == txnas<Applications>(appIdx), comment=expected application to be passed by Index)
    accIdx: uint64 = btoi(txnas<ApplicationArgs>(3))
    assert(acc == txnas<Accounts>(accIdx), comment=expected account to be passed by Index)
    return ARC4_ENCODE(#[asset, app, acc], wtype=arc4.tuple<asset,application,account>)
  }
  
  echoResourceByValue(asset: asset, app: application, acc: account): arc4.tuple<asset,application,account>
  {
    assetId: uint64 = btoi(txnas<ApplicationArgs>(1))
    assert(asset == reinterpret_cast<asset>(assetId), comment=expected asset to be passed by Value)
    appId: uint64 = btoi(txnas<ApplicationArgs>(2))
    assert(app == reinterpret_cast<application>(appId), comment=expected application to be passed by Value)
    address: bytes = txnas<ApplicationArgs>(3)
    assert(acc == reinterpret_cast<account>(address), comment=expected account to be passed by Value)
    return ARC4_ENCODE(#[asset, app, acc], wtype=arc4.tuple<asset,application,account>)
  }
  
  __algots__.defaultCreate(): void
  {
  }
  
}
contract C2C
{
  approvalProgram(): bool
  {
    return arc4Router()
  }
  
  clearProgram(): bool
  {
    return True
  }
  
  testCallToIndex(account: account, appId: application): void
  {
    #[res1]: readonly [uint64] = #[($0 = #{ itxn: ($1 = submit_txn(create_inner_transaction(Fee=0, TypeEnum=appl, ApplicationID=appId, ApplicationArgs=#[Method("testExplicitIndex(account)uint64"), 1], Accounts=#[account]))), returnValue: ARC4_DECODE(reinterpret_cast<arc4.uint64>(checked_maybe(#[extract<4, 0>(($2 = $1.LastLog)), extract<0, 4>($2) == 0x151f7c75], comment=Bytes has valid prefix))) }).returnValue]
    assert(res1 == checked_maybe(acct_params_get<AcctBalance>(account), comment=account funded))
  }
  
  testCallToValue(account: account, appId: application): void
  {
    #[res1]: readonly [uint64] = #[($3 = #{ itxn: ($4 = submit_txn(create_inner_transaction(Fee=0, TypeEnum=appl, ApplicationID=appId, ApplicationArgs=#[Method("testExplicitValue(address)uint64"), ARC4_ENCODE(account, wtype=arc4.static_array<arc4.byte>)]))), returnValue: ARC4_DECODE(reinterpret_cast<arc4.uint64>(checked_maybe(#[extract<4, 0>(($5 = $4.LastLog)), extract<0, 4>($5) == 0x151f7c75], comment=Bytes has valid prefix))) }).returnValue]
    assert(res1 == checked_maybe(acct_params_get<AcctBalance>(account), comment=account funded))
  }
  
  testCallToEchoResource(): void
  {
    compiled: CompiledContract{ approvalProgram: readonly [bytes, bytes], clearStateProgram: readonly [bytes, bytes], extraProgramPages: uint64, globalUints: uint64, globalBytes: uint64, localUints: uint64, localBytes: uint64 } = compile(tests/approvals/resource-encoding.algo.ts::EchoResource
    appId: application = submit_txn(create_inner_transaction(Fee=0, TypeEnum=appl, OnCompletion=0, ApprovalProgramPages=compiled.approvalProgram, ClearStateProgramPages=compiled.clearStateProgram, GlobalNumUint=compiled.globalUints, GlobalNumByteSlice=compiled.globalBytes, LocalNumByteSlice=compiled.localBytes, LocalNumUint=compiled.localUints, ExtraProgramPages=compiled.extraProgramPages)).CreatedApplicationID
    asset: asset = submit_txn(create_inner_transaction(Fee=0, TypeEnum=3, ConfigAssetTotal=1, ConfigAssetUnitName="T", ConfigAssetName="TEST")).CreatedAssetID
    #[indexes]: readonly [arc4.tuple<asset,application,account>] = #[($6 = #{ itxn: ($7 = submit_txn(create_inner_transaction(Fee=0, TypeEnum=appl, ApplicationID=appId, OnCompletion=0, ApplicationArgs=#[Method("echoResourceByIndex(asset,application,account)(uint64,uint64,address)"), 0, 1, 1], Applications=#[global<CurrentApplicationID>()], Assets=#[asset], Accounts=#[txn<Sender>()]))), returnValue: ARC4_DECODE(reinterpret_cast<arc4.tuple<arc4.uint64,arc4.uint64,arc4.static_array<arc4.byte>>>(checked_maybe(#[extract<4, 0>(($8 = $7.LastLog)), extract<0, 4>($8) == 0x151f7c75], comment=Bytes has valid prefix))) }).returnValue]
    assert(&&(&&(&&(3 == 3, indexes.0 == asset), indexes.1 == global<CurrentApplicationID>()), indexes.2 == txn<Sender>()), comment=assert target is match for conditions)
    #[resources]: readonly [arc4.tuple<asset,application,account>] = #[($9 = #{ itxn: ($10 = submit_txn(create_inner_transaction(Fee=0, TypeEnum=appl, ApplicationID=appId, OnCompletion=0, ApplicationArgs=#[Method("echoResourceByValue(uint64,uint64,address)(uint64,uint64,address)"), ARC4_ENCODE(asset, wtype=arc4.uint64), ARC4_ENCODE(global<CurrentApplicationID>(), wtype=arc4.uint64), ARC4_ENCODE(txn<Sender>(), wtype=arc4.static_array<arc4.byte>)]))), returnValue: ARC4_DECODE(reinterpret_cast<arc4.tuple<arc4.uint64,arc4.uint64,arc4.static_array<arc4.byte>>>(checked_maybe(#[extract<4, 0>(($11 = $10.LastLog)), extract<0, 4>($11) == 0x151f7c75], comment=Bytes has valid prefix))) }).returnValue]
    assert(&&(&&(&&(3 == 3, resources.0 == asset), resources.1 == global<CurrentApplicationID>()), resources.2 == txn<Sender>()), comment=assert target is match for conditions)
  }
  
  __algots__.defaultCreate(): void
  {
  }
  
}