#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 2 8
    bytecblock 0x0002
    // tests/approvals/assignments.algo.ts:19-20
    // @contract({ scratchSlots: [countSlot] })
    // export class AssignmentsAlgo extends Contract {
    txn NumAppArgs
    bz main_bare_routing@13
    pushbytess 0x702ea108 0x5b2f7713 0x90cccb3d 0xd8be93bf 0x5a3fec5a 0x27a4f367 0xd6c9f486 0x6e03ad0c // method "testPrimitives(uint64)void", method "testArrayDestructure(uint64[],uint64,uint64[])void", method "testArrayNarrowing(uint64[],uint64)void", method "testTupleToArray((uint64,uint64),(uint64,uint64))void", method "testNested(uint64[][])void", method "testDestructureObj((uint64,string),(uint64,string))void", method "testObjLiteralNarrowing(uint64,uint64)void", method "testMixed(((uint64))[])void"
    txna ApplicationArgs 0
    match main_testPrimitives_route@3 main_testArrayDestructure_route@4 main_testArrayNarrowing_route@5 main_testTupleToArray_route@6 main_testNested_route@7 main_testDestructureObj_route@8 main_testObjLiteralNarrowing_route@9 main_testMixed_route@10

main_after_if_else@17:
    // tests/approvals/assignments.algo.ts:19-20
    // @contract({ scratchSlots: [countSlot] })
    // export class AssignmentsAlgo extends Contract {
    intc_1 // 0
    return

main_testMixed_route@10:
    // tests/approvals/assignments.algo.ts:96
    // testMixed(m: Array<{ a: [uint64] }>) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_0 // 1
    return

main_testObjLiteralNarrowing_route@9:
    // tests/approvals/assignments.algo.ts:83
    // testObjLiteralNarrowing(a: uint64, b: uint64) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_0 // 1
    return

main_testDestructureObj_route@8:
    // tests/approvals/assignments.algo.ts:78
    // testDestructureObj(m: { a: uint64; b: string }, i: Readonly<{ a: uint64; b: string }>) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_0 // 1
    return

main_testNested_route@7:
    // tests/approvals/assignments.algo.ts:73
    // testNested(i_a: ReadonlyArray<ReadonlyArray<uint64>>) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // tests/approvals/assignments.algo.ts:19-20
    // @contract({ scratchSlots: [countSlot] })
    // export class AssignmentsAlgo extends Contract {
    txna ApplicationArgs 1
    // tests/approvals/assignments.algo.ts:73
    // testNested(i_a: ReadonlyArray<ReadonlyArray<uint64>>) {
    callsub testNested
    intc_0 // 1
    return

main_testTupleToArray_route@6:
    // tests/approvals/assignments.algo.ts:63
    // testTupleToArray(m_t: [uint64, uint64], i_t: readonly [uint64, uint64]) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // tests/approvals/assignments.algo.ts:19-20
    // @contract({ scratchSlots: [countSlot] })
    // export class AssignmentsAlgo extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    dup
    intc_1 // 0
    extract_uint64
    swap
    intc_3 // 8
    extract_uint64
    // tests/approvals/assignments.algo.ts:63
    // testTupleToArray(m_t: [uint64, uint64], i_t: readonly [uint64, uint64]) {
    callsub testTupleToArray
    intc_0 // 1
    return

main_testArrayNarrowing_route@5:
    // tests/approvals/assignments.algo.ts:49
    // testArrayNarrowing(m_a: uint64[], u: uint64) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // tests/approvals/assignments.algo.ts:19-20
    // @contract({ scratchSlots: [countSlot] })
    // export class AssignmentsAlgo extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // tests/approvals/assignments.algo.ts:49
    // testArrayNarrowing(m_a: uint64[], u: uint64) {
    callsub testArrayNarrowing
    intc_0 // 1
    return

main_testArrayDestructure_route@4:
    // tests/approvals/assignments.algo.ts:29
    // testArrayDestructure(i_a: ReadonlyArray<uint64>, u: uint64, m_a: uint64[]) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // tests/approvals/assignments.algo.ts:19-20
    // @contract({ scratchSlots: [countSlot] })
    // export class AssignmentsAlgo extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    // tests/approvals/assignments.algo.ts:29
    // testArrayDestructure(i_a: ReadonlyArray<uint64>, u: uint64, m_a: uint64[]) {
    callsub testArrayDestructure
    intc_0 // 1
    return

main_testPrimitives_route@3:
    // tests/approvals/assignments.algo.ts:21
    // testPrimitives(u: uint64) {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_0 // 1
    return

main_bare_routing@13:
    // tests/approvals/assignments.algo.ts:19-20
    // @contract({ scratchSlots: [countSlot] })
    // export class AssignmentsAlgo extends Contract {
    txn OnCompletion
    bnz main_after_if_else@17
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// tests/approvals/assignments.algo.ts::logAndReturn(u: uint64) -> uint64:
logAndReturn:
    // tests/approvals/assignments.algo.ts:114
    // function logAndReturn(u: uint64): uint64 {
    proto 1 1
    // tests/approvals/assignments.algo.ts:16
    // op.Scratch.store(countSlot, op.Scratch.loadUint64(countSlot) + 1)
    load 0
    intc_0 // 1
    +
    store 0
    // tests/approvals/assignments.algo.ts:116
    // log(u)
    frame_dig -1
    itob
    log
    // tests/approvals/assignments.algo.ts:117
    // return u
    frame_dig -1
    retsub


// tests/approvals/assignments.algo.ts::AssignmentsAlgo.testArrayDestructure(i_a: bytes, u: uint64, m_a: bytes) -> void:
testArrayDestructure:
    // tests/approvals/assignments.algo.ts:29
    // testArrayDestructure(i_a: ReadonlyArray<uint64>, u: uint64, m_a: uint64[]) {
    proto 3 0
    pushbytes ""
    // tests/approvals/assignments.algo.ts:9
    // op.Scratch.store(countSlot, 0)
    intc_1 // 0
    store 0
    // tests/approvals/assignments.algo.ts:34
    // const a5 = ([a2, a3] = [logAndReturn(u), logAndReturn(u), logAndReturn(u)])
    frame_dig -2
    callsub logAndReturn
    frame_dig -2
    callsub logAndReturn
    frame_dig -2
    callsub logAndReturn
    dig 2
    itob
    dig 2
    itob
    concat
    swap
    itob
    concat
    dup
    cover 3
    // tests/approvals/assignments.algo.ts:12
    // return op.Scratch.loadUint64(countSlot)
    load 0
    // tests/approvals/assignments.algo.ts:35
    // assert(getCount() === 3, 'logAndReturn called 3 times')
    pushint 3 // 3
    ==
    assert // logAndReturn called 3 times
    // tests/approvals/assignments.algo.ts:36
    // assert(a2 === u)
    uncover 2
    frame_dig -2
    ==
    assert
    // tests/approvals/assignments.algo.ts:37
    // assert(a3 === u)
    swap
    frame_dig -2
    ==
    assert
    // tests/approvals/assignments.algo.ts:38
    // assertMatch(a5, [u, u, u])
    intc_1 // 0
    extract_uint64
    frame_dig -2
    ==
    bz testArrayDestructure_bool_false@5
    frame_dig 1
    intc_3 // 8
    extract_uint64
    frame_dig -2
    ==
    bz testArrayDestructure_bool_false@5
    frame_dig 1
    pushint 16 // 16
    extract_uint64
    frame_dig -2
    ==
    bz testArrayDestructure_bool_false@5
    intc_0 // 1

testArrayDestructure_bool_merge@6:
    // tests/approvals/assignments.algo.ts:38
    // assertMatch(a5, [u, u, u])
    assert // assert target is match for conditions
    // tests/approvals/assignments.algo.ts:42
    // const [c, d] = [logAndReturn(u), logAndReturn(u), logAndReturn(u)]
    frame_dig -2
    callsub logAndReturn
    frame_dig -2
    callsub logAndReturn
    frame_bury 0
    frame_dig -2
    callsub logAndReturn
    pop
    // tests/approvals/assignments.algo.ts:43
    // assertMatch([c, d], [u, u])
    frame_dig -2
    ==
    bz testArrayDestructure_bool_false@10
    frame_dig 0
    frame_dig -2
    ==
    bz testArrayDestructure_bool_false@10
    intc_0 // 1

testArrayDestructure_bool_merge@11:
    // tests/approvals/assignments.algo.ts:43
    // assertMatch([c, d], [u, u])
    assert // assert target is match for conditions
    retsub

testArrayDestructure_bool_false@10:
    intc_1 // 0
    b testArrayDestructure_bool_merge@11

testArrayDestructure_bool_false@5:
    intc_1 // 0
    b testArrayDestructure_bool_merge@6


// tests/approvals/assignments.algo.ts::AssignmentsAlgo.testArrayNarrowing(m_a: bytes, u: uint64) -> void:
testArrayNarrowing:
    // tests/approvals/assignments.algo.ts:49
    // testArrayNarrowing(m_a: uint64[], u: uint64) {
    proto 2 0
    // tests/approvals/assignments.algo.ts:51
    // m_a[0] += 1
    frame_dig -2
    intc_2 // 2
    extract_uint64
    dup
    intc_0 // 1
    +
    itob
    frame_dig -2
    swap
    replace2 2
    // tests/approvals/assignments.algo.ts:52
    // direct[0] += 2
    swap
    intc_2 // 2
    +
    itob
    frame_dig -2
    swap
    replace2 2
    // tests/approvals/assignments.algo.ts:53
    // assert(m_a[0] !== direct[0])
    swap
    intc_2 // 2
    extract_uint64
    swap
    intc_2 // 2
    extract_uint64
    !=
    assert
    retsub


// tests/approvals/assignments.algo.ts::AssignmentsAlgo.testTupleToArray(m_t: bytes, i_t.0: uint64, i_t.1: uint64) -> void:
testTupleToArray:
    // tests/approvals/assignments.algo.ts:63
    // testTupleToArray(m_t: [uint64, uint64], i_t: readonly [uint64, uint64]) {
    proto 3 0
    intc_1 // 0
    // tests/approvals/assignments.algo.ts:64
    // const m_a: uint64[] = clone(m_t)
    frame_dig -3
    intc_1 // 0
    extract_uint64
    dup
    frame_dig -3
    intc_3 // 8
    extract_uint64
    dup
    uncover 2
    itob
    bytec_0 // 0x0002
    swap
    concat
    swap
    itob
    concat
    dup
    // tests/approvals/assignments.algo.ts:65
    // assertMatch(m_a, m_t)
    intc_1 // 0
    extract_uint16
    intc_2 // 2
    ==
    dup
    bz testTupleToArray_bool_false@4
    frame_dig 3
    intc_2 // 2
    extract_uint64
    frame_dig 1
    ==
    bz testTupleToArray_bool_false@4
    frame_dig 3
    pushint 10 // 10
    extract_uint64
    frame_dig 2
    ==
    bz testTupleToArray_bool_false@4
    intc_0 // 1

testTupleToArray_bool_merge@5:
    // tests/approvals/assignments.algo.ts:65
    // assertMatch(m_a, m_t)
    assert // assert target is match for conditions
    // tests/approvals/assignments.algo.ts:67
    // assertMatch(i_a, m_t)
    frame_dig 4
    bz testTupleToArray_bool_false@9
    frame_dig 3
    intc_2 // 2
    extract_uint64
    frame_dig 1
    ==
    bz testTupleToArray_bool_false@9
    frame_dig 3
    pushint 10 // 10
    extract_uint64
    frame_dig 2
    ==
    bz testTupleToArray_bool_false@9
    intc_0 // 1

testTupleToArray_bool_merge@10:
    // tests/approvals/assignments.algo.ts:67
    // assertMatch(i_a, m_t)
    assert // assert target is match for conditions
    // tests/approvals/assignments.algo.ts:69
    // const i_a2: readonly uint64[] = i_t
    frame_dig -2
    itob
    bytec_0 // 0x0002
    swap
    concat
    frame_dig -1
    itob
    concat
    dup
    frame_bury 0
    // tests/approvals/assignments.algo.ts:70
    // assertMatch(i_a2, i_t)
    intc_1 // 0
    extract_uint16
    intc_2 // 2
    ==
    bz testTupleToArray_bool_false@14
    frame_dig 0
    intc_2 // 2
    extract_uint64
    frame_dig -2
    ==
    bz testTupleToArray_bool_false@14
    frame_dig 0
    pushint 10 // 10
    extract_uint64
    frame_dig -1
    ==
    bz testTupleToArray_bool_false@14
    intc_0 // 1

testTupleToArray_bool_merge@15:
    // tests/approvals/assignments.algo.ts:70
    // assertMatch(i_a2, i_t)
    assert // assert target is match for conditions
    retsub

testTupleToArray_bool_false@14:
    intc_1 // 0
    b testTupleToArray_bool_merge@15

testTupleToArray_bool_false@9:
    intc_1 // 0
    b testTupleToArray_bool_merge@10

testTupleToArray_bool_false@4:
    intc_1 // 0
    b testTupleToArray_bool_merge@5


// tests/approvals/assignments.algo.ts::AssignmentsAlgo.testNested(i_a: bytes) -> void:
testNested:
    // tests/approvals/assignments.algo.ts:73
    // testNested(i_a: ReadonlyArray<ReadonlyArray<uint64>>) {
    proto 1 0
    // tests/approvals/assignments.algo.ts:74
    // const [[a]] = i_a
    frame_dig -1
    intc_1 // 0
    extract_uint16
    assert // index access is out of bounds
    retsub
