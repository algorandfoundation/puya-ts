#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 2 0 8
    bytecblock 0x0002
    // tests/approvals/assignments.algo.ts:19-20
    // @contract({ scratchSlots: [countSlot] })
    // export class AssignmentsAlgo extends Contract {
    txn NumAppArgs
    bz main___algots__.defaultCreate@16
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x702ea108 0xedda85e9 0x5b2f7713 0x90cccb3d 0xd8be93bf 0x5a3fec5a 0x27a4f367 0xd6c9f486 0x6e03ad0c // method "testPrimitives(uint64)void", method "testAccountDestructure()(uint64,uint64)", method "testArrayDestructure(uint64[],uint64,uint64[])void", method "testArrayNarrowing(uint64[],uint64)void", method "testTupleToArray((uint64,uint64),(uint64,uint64))void", method "testNested(uint64[][])void", method "testDestructureObj((uint64,string),(uint64,string))void", method "testObjLiteralNarrowing(uint64,uint64)void", method "testMixed(((uint64))[])void"
    txna ApplicationArgs 0
    match testPrimitives testAccountDestructure testArrayDestructure testArrayNarrowing testTupleToArray testNested testDestructureObj testObjLiteralNarrowing testMixed
    err

main___algots__.defaultCreate@16:
    // tests/approvals/assignments.algo.ts:19-20
    // @contract({ scratchSlots: [countSlot] })
    // export class AssignmentsAlgo extends Contract {
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_0 // 1
    return


// tests/approvals/assignments.algo.ts::AssignmentsAlgo.testPrimitives[routing]() -> void:
testPrimitives:
    // tests/approvals/assignments.algo.ts:21
    // testPrimitives(u: uint64) {
    txna ApplicationArgs 1
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    intc_0 // 1
    return


// tests/approvals/assignments.algo.ts::AssignmentsAlgo.testAccountDestructure[routing]() -> void:
testAccountDestructure:
    // tests/approvals/assignments.algo.ts:30
    // const { balance, minBalance } = Global.currentApplicationAddress
    global CurrentApplicationAddress
    dup
    acct_params_get AcctBalance
    assert // account funded
    swap
    acct_params_get AcctMinBalance
    assert // account funded
    // tests/approvals/assignments.algo.ts:31
    // return { balance, minBalance }
    swap
    itob
    swap
    itob
    concat
    // tests/approvals/assignments.algo.ts:29
    // testAccountDestructure() {
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// tests/approvals/assignments.algo.ts::AssignmentsAlgo.testArrayDestructure[routing]() -> void:
testArrayDestructure:
    // tests/approvals/assignments.algo.ts:34
    // testArrayDestructure(i_a: ReadonlyArray<uint64>, u: uint64, m_a: uint64[]) {
    txna ApplicationArgs 1
    dup
    intc_2 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 8
    *
    intc_1 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 3
    dup
    intc_2 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 8
    *
    intc_1 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    // tests/approvals/assignments.algo.ts:9
    // op.Scratch.store(countSlot, 0)
    intc_2 // 0
    store 0
    // tests/approvals/assignments.algo.ts:16
    // op.Scratch.store(countSlot, op.Scratch.loadUint64(countSlot) + 1)
    load 0
    intc_0 // 1
    +
    store 0
    // tests/approvals/assignments.algo.ts:124
    // log(u)
    dup
    itob
    dup
    log
    // tests/approvals/assignments.algo.ts:16
    // op.Scratch.store(countSlot, op.Scratch.loadUint64(countSlot) + 1)
    load 0
    intc_0 // 1
    +
    store 0
    // tests/approvals/assignments.algo.ts:124
    // log(u)
    dup
    log
    // tests/approvals/assignments.algo.ts:16
    // op.Scratch.store(countSlot, op.Scratch.loadUint64(countSlot) + 1)
    load 0
    intc_0 // 1
    +
    store 0
    // tests/approvals/assignments.algo.ts:124
    // log(u)
    dup
    log
    // tests/approvals/assignments.algo.ts:39
    // const a5 = ([a2, a3] = [logAndReturn(u), logAndReturn(u), logAndReturn(u)])
    dup
    dig 1
    concat
    dig 1
    concat
    // tests/approvals/assignments.algo.ts:12
    // return op.Scratch.loadUint64(countSlot)
    load 0
    // tests/approvals/assignments.algo.ts:40
    // assert(getCount() === 3, 'logAndReturn called 3 times')
    pushint 3 // 3
    ==
    assert // logAndReturn called 3 times
    // tests/approvals/assignments.algo.ts:43
    // assertMatch(a5, [u, u, u])
    dup
    intc_2 // 0
    extract_uint64
    dig 3
    ==
    intc_0 // 1
    &&
    dig 1
    intc_3 // 8
    extract_uint64
    dig 4
    ==
    &&
    swap
    pushint 16 // 16
    extract_uint64
    uncover 3
    ==
    &&
    assert // assert target is match for conditions
    // tests/approvals/assignments.algo.ts:16
    // op.Scratch.store(countSlot, op.Scratch.loadUint64(countSlot) + 1)
    load 0
    intc_0 // 1
    +
    store 0
    // tests/approvals/assignments.algo.ts:124
    // log(u)
    dup
    log
    // tests/approvals/assignments.algo.ts:16
    // op.Scratch.store(countSlot, op.Scratch.loadUint64(countSlot) + 1)
    load 0
    intc_0 // 1
    +
    store 0
    // tests/approvals/assignments.algo.ts:124
    // log(u)
    dup
    log
    // tests/approvals/assignments.algo.ts:16
    // op.Scratch.store(countSlot, op.Scratch.loadUint64(countSlot) + 1)
    load 0
    intc_0 // 1
    +
    store 0
    // tests/approvals/assignments.algo.ts:124
    // log(u)
    log
    // tests/approvals/assignments.algo.ts:34
    // testArrayDestructure(i_a: ReadonlyArray<uint64>, u: uint64, m_a: uint64[]) {
    intc_0 // 1
    return


// tests/approvals/assignments.algo.ts::AssignmentsAlgo.testArrayNarrowing[routing]() -> void:
testArrayNarrowing:
    // tests/approvals/assignments.algo.ts:54
    // testArrayNarrowing(m_a: uint64[], u: uint64) {
    txna ApplicationArgs 1
    dup
    intc_2 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 8
    *
    intc_1 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    txna ApplicationArgs 2
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // tests/approvals/assignments.algo.ts:56
    // m_a[0] += 1
    dup
    intc_1 // 2
    extract_uint64
    dup
    intc_0 // 1
    +
    itob
    dig 2
    swap
    replace2 2 // on error: index access is out of bounds
    // tests/approvals/assignments.algo.ts:57
    // direct[0] += 2
    swap
    intc_1 // 2
    +
    itob
    uncover 2
    swap
    replace2 2 // on error: index access is out of bounds
    // tests/approvals/assignments.algo.ts:58
    // assert(m_a[0] !== direct[0])
    swap
    intc_1 // 2
    extract_uint64
    swap
    intc_1 // 2
    extract_uint64
    !=
    // tests/approvals/assignments.algo.ts:54
    // testArrayNarrowing(m_a: uint64[], u: uint64) {
    return


// tests/approvals/assignments.algo.ts::AssignmentsAlgo.testTupleToArray[routing]() -> void:
testTupleToArray:
    // tests/approvals/assignments.algo.ts:68
    // testTupleToArray(m_t: [uint64, uint64], i_t: readonly [uint64, uint64]) {
    txna ApplicationArgs 1
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid number of bytes for arc4.tuple<uint64,uint64>
    txna ApplicationArgs 2
    dup
    len
    pushint 16 // 16
    ==
    assert // invalid number of bytes for arc4.tuple<arc4.uint64,arc4.uint64>
    dup
    intc_2 // 0
    extract_uint64
    swap
    intc_3 // 8
    extract_uint64
    // tests/approvals/assignments.algo.ts:69
    // const m_a: uint64[] = clone(m_t)
    dig 2
    intc_2 // 0
    extract_uint64
    uncover 3
    intc_3 // 8
    extract_uint64
    dig 1
    itob
    bytec_0 // 0x0002
    swap
    concat
    dig 1
    itob
    concat
    // tests/approvals/assignments.algo.ts:70
    // assertMatch(m_a, m_t)
    dup
    intc_2 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 2
    ==
    dig 1
    intc_1 // 2
    extract_uint64
    uncover 4
    ==
    &&
    swap
    pushint 10 // 10
    extract_uint64
    uncover 2
    ==
    &&
    assert // assert target is match for conditions
    // tests/approvals/assignments.algo.ts:74
    // const i_a2: readonly uint64[] = i_t
    dig 1
    itob
    bytec_0 // 0x0002
    swap
    concat
    dig 1
    itob
    concat
    // tests/approvals/assignments.algo.ts:75
    // assertMatch(i_a2, i_t)
    dup
    intc_2 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 2
    ==
    dig 1
    intc_1 // 2
    extract_uint64
    uncover 4
    ==
    &&
    swap
    pushint 10 // 10
    extract_uint64
    uncover 2
    ==
    &&
    assert // assert target is match for conditions
    // tests/approvals/assignments.algo.ts:68
    // testTupleToArray(m_t: [uint64, uint64], i_t: readonly [uint64, uint64]) {
    intc_0 // 1
    return


// tests/approvals/assignments.algo.ts::AssignmentsAlgo.testNested[routing]() -> void:
testNested:
    // tests/approvals/assignments.algo.ts:78
    // testNested(i_a: ReadonlyArray<ReadonlyArray<uint64>>) {
    txna ApplicationArgs 1
    dup
    intc_2 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_1 // 2
    *
    swap
    dup
    len
    swap
    extract 2 0
    intc_2 // 0

testNested_for_header@1:
    // tests/approvals/assignments.algo.ts:78
    // testNested(i_a: ReadonlyArray<ReadonlyArray<uint64>>) {
    dup
    dig 5
    <
    bz testNested_after_for@4
    dupn 2
    intc_1 // 2
    *
    dig 3
    dup
    uncover 2
    extract_uint16 // on error: invalid array encoding
    dup
    dig 7
    dup
    cover 4
    ==
    assert // invalid tail pointer for (len+(len+uint64[])[])
    dig 1
    len
    substring3
    intc_2 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 8
    *
    intc_1 // 2
    +
    +
    bury 5
    intc_0 // 1
    +
    bury 1
    b testNested_for_header@1

testNested_after_for@4:
    // tests/approvals/assignments.algo.ts:78
    // testNested(i_a: ReadonlyArray<ReadonlyArray<uint64>>) {
    dig 3
    intc_1 // 2
    +
    dig 3
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.dynamic_array<uint64>>
    intc_0 // 1
    return


// tests/approvals/assignments.algo.ts::AssignmentsAlgo.testDestructureObj[routing]() -> void:
testDestructureObj:
    // tests/approvals/assignments.algo.ts:83
    // testDestructureObj(m: { a: uint64; b: string }, i: Readonly<{ a: uint64; b: string }>) {
    txna ApplicationArgs 1
    dup
    len
    dig 1
    intc_3 // 8
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 10 // 10
    ==
    assert // invalid tail pointer at index 1 of (uint64,(len+utf8[]))
    uncover 2
    swap
    dig 2
    substring3
    intc_2 // 0
    extract_uint16 // on error: invalid array length header
    pushint 12 // 12
    +
    ==
    assert // invalid number of bytes for Object3EB715E7
    txna ApplicationArgs 2
    dup
    len
    dig 1
    intc_3 // 8
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 10 // 10
    ==
    assert // invalid tail pointer at index 1 of (uint64,(len+utf8[]))
    uncover 2
    swap
    dig 2
    substring3
    intc_2 // 0
    extract_uint16 // on error: invalid array length header
    pushint 12 // 12
    +
    ==
    assert // invalid number of bytes for ReadonlyObject3EB715E7
    intc_0 // 1
    return


// tests/approvals/assignments.algo.ts::AssignmentsAlgo.testObjLiteralNarrowing[routing]() -> void:
testObjLiteralNarrowing:
    // tests/approvals/assignments.algo.ts:88
    // testObjLiteralNarrowing(a: uint64, b: uint64) {
    txna ApplicationArgs 1
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 2
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // tests/approvals/assignments.algo.ts:9
    // op.Scratch.store(countSlot, 0)
    intc_2 // 0
    store 0
    // tests/approvals/assignments.algo.ts:16
    // op.Scratch.store(countSlot, op.Scratch.loadUint64(countSlot) + 1)
    load 0
    intc_0 // 1
    +
    store 0
    // tests/approvals/assignments.algo.ts:12
    // return op.Scratch.loadUint64(countSlot)
    load 0
    // tests/approvals/assignments.algo.ts:97
    // assert(getCount() === 1, 'getVal should only be called once')
    intc_0 // 1
    ==
    assert // getVal should only be called once
    // tests/approvals/assignments.algo.ts:16
    // op.Scratch.store(countSlot, op.Scratch.loadUint64(countSlot) + 1)
    load 0
    intc_0 // 1
    +
    store 0
    // tests/approvals/assignments.algo.ts:12
    // return op.Scratch.loadUint64(countSlot)
    load 0
    // tests/approvals/assignments.algo.ts:100
    // assert(getCount() === 2, 'getVal should still be called once even though its result is not used')
    intc_1 // 2
    ==
    assert // getVal should still be called once even though its result is not used
    // tests/approvals/assignments.algo.ts:88
    // testObjLiteralNarrowing(a: uint64, b: uint64) {
    intc_0 // 1
    return


// tests/approvals/assignments.algo.ts::AssignmentsAlgo.testMixed[routing]() -> void:
testMixed:
    // tests/approvals/assignments.algo.ts:103
    // testMixed(m: Array<{ a: [uint64] }>) {
    txna ApplicationArgs 1
    dup
    intc_2 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 8
    *
    intc_1 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<Object7CFAF5D6>
    intc_0 // 1
    return
