import { camelCase } from 'change-case'
import { enumerate } from '../src/util'
import type { OpFunction, OpGrouping, OpModule, OpOverloadedFunction } from './build-op-module'
import { AlgoTsType, BytesAlgoTsType, EnumAlgoTsType, UnionAlgoTsType } from './build-op-module'

export function* emitOpMetaData(opModule: OpModule) {
  function* emitHeader() {
    yield `
/* THIS FILE IS GENERATED BY ~/scripts/generate-op-metadata.ts - DO NOT MODIFY DIRECTLY */
import * as ptypes from './ptypes'
import { Expression } from '../awst/nodes'

export type ImmediateArgMapping = {
  name: string
  ptypes: ptypes.PType[]
}


export type StackArg = {
  name: string
  ptypes: ptypes.PType[]
}

export type Signature = {
  argNames: string[]
  immediateArgs: Array<ImmediateArgMapping | bigint | string>
  stackArgs: Array<StackArg | Expression>
  returnType: ptypes.PType
}

export type IntrinsicOpMapping = {
  type: 'op-mapping'
  op: string
  signatures: Signature[]
}
export type IntrinsicOpGrouping = {
  type: 'op-grouping'
  name: string
  ops: Record<string, IntrinsicOpMapping>
}
`
  }

  function* algoTsToPType(t: AlgoTsType): Generator<string> {
    if (t instanceof UnionAlgoTsType) {
      for (const _t of t.types) {
        yield* algoTsToPType(_t)
      }

      return
    }
    if (t instanceof EnumAlgoTsType) {
      yield `ptypes.${camelCase(t.tsName)}PType`
      return
    }
    if (t instanceof BytesAlgoTsType) {
      yield `new ptypes.BytesPType({length: ${t.size}n})`
      return
    }
    switch (t) {
      case AlgoTsType.Asset:
        yield 'ptypes.assetPType'
        return
      case AlgoTsType.Account:
        yield 'ptypes.accountPType'
        return
      case AlgoTsType.Application:
        yield 'ptypes.applicationPType'
        return
      case AlgoTsType.Uint64:
        yield 'ptypes.uint64PType'
        return
      case AlgoTsType.BigUint:
        yield 'ptypes.biguintPType'
        return
      case AlgoTsType.Boolean:
        yield 'ptypes.boolPType'
        return
      case AlgoTsType.Void:
        yield 'ptypes.voidPType'
        return
      case AlgoTsType.Bytes:
        yield 'ptypes.bytesPType'
        return
      case AlgoTsType.String:
        yield 'ptypes.stringPType'
        return
      case AlgoTsType.OnCompletion:
        yield 'ptypes.onCompleteActionType.memberType'
        return
      case AlgoTsType.TransactionType:
        yield 'ptypes.transactionTypeType.memberType'
        return
    }
    throw new Error(`Unhandled flags ${t}`)
  }

  function mapReturnType(returnTypes: AlgoTsType[]) {
    if (returnTypes.length === 0) {
      return 'ptypes.voidPType'
    }
    const ptypes = returnTypes.map((t) => {
      const mapped = Array.from(algoTsToPType(t))
      if (mapped.length === 1) {
        return mapped[0]
      }
      throw new Error(`Cannot have union return types: ${t.name}`)
    })
    if (ptypes.length === 1) {
      return ptypes[0]
    }
    return `new ptypes.TuplePType({items: [${ptypes.join(', ')}]})`
  }

  function* emitTypes() {
    function* emitOpMapping(op: OpFunction) {
      yield `'${op.name}': `
      yield `{`
      yield `type: 'op-mapping',`
      yield `op: '${op.opCode}',`
      yield `signatures: [{`
      yield `argNames: [`
      for (const [index, arg] of enumerate(op.immediateArgs)) {
        if (index === op.enumArg?.pos) continue
        yield `'${arg.name}',`
      }
      yield op.stackArgs.map((a) => `'${a.name}'`).join(', ')
      yield '],'
      yield 'immediateArgs: ['
      for (const [index, ia] of enumerate(op.immediateArgs)) {
        if (op.enumArg?.pos === index) {
          yield `'${op.enumArg.member}',`
        } else {
          yield `{ name: '${ia.name}', ptypes: [${Array.from(algoTsToPType(ia.type)).join(', ')}] },`
        }
      }
      yield '],'
      yield 'stackArgs: ['
      for (const sa of op.stackArgs) {
        yield `{ name: '${sa.name}', ptypes: [${Array.from(algoTsToPType(sa.type)).join(', ')}] },`
      }
      yield '],'
      yield `returnType: ${mapReturnType(op.returnTypes)},`
      yield `}]`
      yield '},'
    }

    function* emitOpOverloadedMapping(op: OpOverloadedFunction) {
      yield `'${op.name}': `
      yield `{`
      yield `type: 'op-mapping',`
      yield `op: '${op.opCode}',`
      yield `signatures: [`
      for (const signature of op.signatures) {
        yield '{'
        yield `argNames: [`
        for (const arg of signature.immediateArgs) {
          yield `'${arg.name}',`
        }
        yield signature.stackArgs.map((a) => `'${a.name}'`).join(', ')
        yield '],'
        yield 'immediateArgs: ['
        for (const ia of signature.immediateArgs) {
          yield `{ name: '${ia.name}', ptypes: [${Array.from(algoTsToPType(ia.type)).join(', ')}] },`
        }
        yield '],'
        yield 'stackArgs: ['
        for (const sa of signature.stackArgs) {
          yield `{ name: '${sa.name}', ptypes: [${Array.from(algoTsToPType(sa.type)).join(', ')}] },`
        }
        yield '],'
        yield `returnType: ${mapReturnType(signature.returnTypes)},`
        yield '},'
      }
      yield `]`
      yield '},'
    }

    function* emitOpGrouping(group: OpGrouping) {
      yield `${group.name}: `
      yield `{`
      yield `type: 'op-grouping',`
      yield `name: '${group.name}',`
      yield `ops: {`

      for (const op of Object.values(group.functions)) {
        yield* emitOpMapping(op)
      }

      yield `}`
      yield '},'
    }

    yield* emitHeader()
    yield `export const OP_METADATA: Record<string, IntrinsicOpMapping | IntrinsicOpGrouping> = {\n`
    for (const item of opModule.items) {
      if (item.type === 'op-function') {
        yield* emitOpMapping(item)
      } else if (item.type === 'op-overloaded-function') {
        yield* emitOpOverloadedMapping(item)
      } else {
        yield* emitOpGrouping(item)
      }
    }
    yield `\n}`
  }

  yield* emitTypes()
}
