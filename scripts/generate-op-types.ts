import { pascalCase } from 'change-case'
import * as fs from 'fs'
import { enumerate, hasFlags } from '../src/util'
import type { OpModule } from './build-op-module'
import { AlgoTsType, buildOpModule, ENUMS_TO_EXPOSE } from './build-op-module'

function* emitTypes(module: OpModule) {
  function* emitHeader() {
    yield `/* THIS FILE IS GENERATED BY ~/scripts/generate-op-types.ts - DO NOT MODIFY DIRECTLY */
import { bytes, BytesCompat, uint64, Uint64Compat, biguint } from './primitives'
import { Account, Application, Asset } from './reference'

`
  }

  function* emitDoc(doc: string | string[]) {
    if (Array.isArray(doc)) {
      yield '\n/**'
      for (const row of doc) {
        yield '\n  * '
        yield row
      }
      yield '\n */'
    } else if (doc) {
      yield '\n/**'
      yield '\n  * '
      yield doc
      yield '\n */'
    }
    yield '\n'
  }
  function* emitEnums() {
    for (const enumDef of module.enums) {
      if (!ENUMS_TO_EXPOSE.has(enumDef.name)) continue

      yield `export enum ${enumDef.tsName} {`
      for (const member of enumDef.members) {
        yield `${member.name} = '${member.value}',`
      }

      yield `}`
    }
  }

  function* emitReturnType(returnType: AlgoTsType) {
    if (hasFlags(returnType, AlgoTsType.Application)) yield 'Application'
    if (hasFlags(returnType, AlgoTsType.Account)) yield 'Account'
    if (hasFlags(returnType, AlgoTsType.Asset)) yield 'Asset'
    if (hasFlags(returnType, AlgoTsType.Uint64)) yield 'uint64'
    if (hasFlags(returnType, AlgoTsType.Bytes)) yield 'bytes'
    if (hasFlags(returnType, AlgoTsType.Boolean)) yield 'boolean'
    if (hasFlags(returnType, AlgoTsType.BigUint)) yield 'biguint'
    if (hasFlags(returnType, AlgoTsType.Void)) yield 'void'
    if (hasFlags(returnType, AlgoTsType.Enum)) {
      for (const enumDef of opModule.enums.filter((a) => hasFlags(a.typeFlag, returnType))) {
        yield enumDef.tsName
      }
    }
  }
  function* emitReturnTypes(returnTypes: AlgoTsType[]) {
    switch (returnTypes.length) {
      case 0:
        yield 'void'
        break
      case 1:
        yield Array.from(emitReturnType(returnTypes[0])).join(' | ')
        break
      default:
        yield 'readonly ['
        for (const rt of returnTypes) {
          yield Array.from(emitReturnType(rt)).join(' | ')
          yield ','
        }
        yield ']'
        break
    }
  }
  function* emitArgType(argType: AlgoTsType) {
    if (hasFlags(argType, AlgoTsType.Application)) yield 'Application'
    if (hasFlags(argType, AlgoTsType.Account)) yield 'Account'
    if (hasFlags(argType, AlgoTsType.Asset)) yield 'Asset'
    if (hasFlags(argType, AlgoTsType.Uint64)) yield 'uint64'
    if (hasFlags(argType, AlgoTsType.Bytes)) yield 'bytes'
    if (hasFlags(argType, AlgoTsType.Boolean)) yield 'boolean'
    if (hasFlags(argType, AlgoTsType.BigUint)) yield 'biguint'
    if (hasFlags(argType, AlgoTsType.Void)) yield 'void'
    if (hasFlags(argType, AlgoTsType.Enum)) {
      for (const enumDef of opModule.enums.filter((a) => hasFlags(a.typeFlag, argType))) {
        yield enumDef.tsName
      }
    }
  }
  yield* emitEnums()

  for (const item of module.items) {
    if (item.type === 'op-function') {
      yield* emitDoc(item.docs)
      yield `export type ${pascalCase(item.name)}Type = (`
      for (const arg of item.immediateArgs) {
        yield arg.name
        yield ':'
        yield Array.from(emitArgType(arg.type)).join(' | ')
        yield ','
      }
      for (const arg of item.stackArgs) {
        yield arg.name
        yield ':'
        yield Array.from(emitArgType(arg.type)).join(' | ')
        yield ','
      }
      yield `) => `
      yield* emitReturnTypes(item.returnTypes)
      yield '\n'
    } else if (item.type === 'op-overloaded-function') {
      yield `export type ${pascalCase(item.name)}Type = `
      for (const signature of item.signatures) {
        yield '\n  & (('
        for (const arg of signature.immediateArgs) {
          yield arg.name
          yield ':'
          yield Array.from(emitArgType(arg.type)).join(' | ')
          yield ','
        }
        for (const arg of signature.stackArgs) {
          yield arg.name
          yield ':'
          yield Array.from(emitArgType(arg.type)).join(' | ')
          yield ','
        }
        yield `) => `
        yield* emitReturnTypes(signature.returnTypes)
        yield ')\n'
      }
    } else {
      yield* emitDoc(item.docs)

      yield `export type ${item.name}Type = {`

      for (const ol of Object.values(item.functions)) {
        yield '\n'
        yield* emitDoc(ol.docs)
        if (ol.stackArgs.length === 0 && ol.immediateArgs.length === 1) {
          yield 'get '
        }
        yield `${ol.name}(`
        for (const [index, arg] of enumerate(ol.immediateArgs)) {
          if (index === ol.enumArg?.pos) continue
          yield arg.name
          yield ':'
          yield Array.from(emitArgType(arg.type)).join(' | ')
          yield ','
        }
        for (const arg of ol.stackArgs) {
          yield arg.name
          yield ':'
          yield Array.from(emitArgType(arg.type)).join(' | ')
          yield ','
        }
        yield `):`
        yield* emitReturnTypes(ol.returnTypes)
        yield ','
      }

      yield `}\n`
    }
  }

  yield* emitHeader()
  yield `export type OpsNamespace = {\n`
  for (const item of opModule.items) {
    if (item.type === 'op-function' || item.type === 'op-overloaded-function') {
      yield `${item.name}: ${pascalCase(item.name)}Type, `
    } else {
      yield `${item.name}: ${item.name}Type, `
    }
  }
  yield `}`
}
const fullFilePathName = process.argv[2]

const opModule = buildOpModule()
fs.writeFileSync(fullFilePathName, Array.from(emitTypes(opModule)).join(''))
