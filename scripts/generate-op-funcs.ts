import { camelCase } from 'change-case'
import { distinct } from '../src/util'
import type { AlgoTsType, OpArg, OpModule, OpOverloadedFunction } from './build-op-module'
import { ENUMS_TO_EXPOSE, UnionAlgoTsType } from './build-op-module'

export function* emitOpFuncTypes(module: OpModule) {
  function* emitHeader() {
    yield `/* THIS FILE IS GENERATED BY ~/scripts/generate-op-funcs.ts - DO NOT MODIFY DIRECTLY */
import { NoImplementation } from "./internal/errors";
import { bytes, uint64, biguint } from './primitives'
import { Account, Application, Asset } from './reference'
import { OnCompleteAction } from "./on-complete-action";
import { TransactionType } from "./transactions";
`
  }
  function* noImplementation() {
    yield '{'
    yield `throw new NoImplementation()`
    yield '}'
  }

  function* emitDoc(doc: string | string[], minAvmVersion?: number) {
    if (Array.isArray(doc)) {
      yield '\n/**'
      for (const row of doc) {
        yield '\n  * '
        yield row
      }
    } else if (doc) {
      yield '\n/**'
      yield '\n  * '
      yield doc
    } else {
      return
    }
    if (minAvmVersion !== undefined) yield `\n  * Min AVM version: ${minAvmVersion}`
    yield '\n  */'
    yield '\n'
  }
  function* emitEnums() {
    for (const enumDef of module.enums) {
      if (!ENUMS_TO_EXPOSE.has(enumDef.name)) continue

      yield `export enum ${enumDef.tsName} {`
      for (const member of enumDef.members) {
        yield* emitDoc(member.doc)
        yield `${member.name} = '${member.value}',`
      }

      yield `}\n`
    }
  }

  function* emitReturnTypes(returnTypes: AlgoTsType[]) {
    switch (returnTypes.length) {
      case 0:
        yield 'void'
        break
      case 1:
        yield returnTypes[0].tsName
        break
      default:
        yield 'readonly ['
        for (const rt of returnTypes) {
          yield rt.tsName
          yield ','
        }
        yield ']'
        break
    }
  }
  function* emitArg(arg: OpArg) {
    yield arg.name
    if (arg.optional) {
      yield '?'
    }
    yield ':'
    yield arg.type.tsName
    yield ','
  }

  function combineReturnTypes(op: OpOverloadedFunction): string {
    return op.signatures
      .map((s) => Array.from(emitReturnTypes(s.returnTypes)).join(''))
      .filter(distinct())
      .join(' | ')
  }

  yield* emitHeader()

  yield* emitEnums()

  for (const item of module.items) {
    if (item.type === 'op-function') {
      yield* emitDoc(item.docs, item.minAvmVersion)
      yield `export function ${item.name}(`
      for (const arg of item.immediateArgs) {
        yield* emitArg(arg)
      }
      for (const arg of item.stackArgs) {
        yield* emitArg(arg)
      }
      yield `): `
      yield* emitReturnTypes(item.returnTypes)
      yield* noImplementation()
    } else if (item.type === 'op-overloaded-function') {
      for (const signature of item.signatures) {
        yield* emitDoc(signature.docs)
        yield `export function ${camelCase(item.name)}(`
        for (const arg of signature.immediateArgs) {
          yield* emitArg(arg)
        }
        for (const arg of signature.stackArgs) {
          yield* emitArg(arg)
        }
        yield `): `
        yield* emitReturnTypes(signature.returnTypes)
        yield '\n'
      }
      yield `export function ${camelCase(item.name)}(`
      const args = item.signatures
        .map((s) => s.immediateArgs.concat(s.stackArgs))
        .reduce((acc, cur) =>
          new Array(Math.max(acc.length, cur.length)).fill(null).map((_, i): OpArg => {
            const left = acc[i]
            const right = cur[i]
            return left
              ? right
                ? {
                    name: left.name,
                    type: new UnionAlgoTsType(left.type, right.type),
                  }
                : {
                    ...left,
                    optional: true,
                  }
              : {
                  ...right,
                  optional: true,
                }
          }),
        )
      for (const arg of args) {
        yield* emitArg(arg)
      }
      yield '): '
      yield combineReturnTypes(item)
      yield* noImplementation()
    } else {
      yield* emitDoc(item.docs)

      yield `export const ${item.name} = {`

      for (const ol of Object.values(item.functions)) {
        yield '\n'
        yield* emitDoc(ol.docs, ol.minAvmVersion)
        if (ol.stackArgs.length === 0 && ol.immediateArgs.length === 1) {
          yield 'get '
        }
        yield `${ol.name}(`
        for (const [index, arg] of ol.immediateArgs.entries()) {
          if (index === ol.enumArg?.pos) continue

          yield* emitArg(arg)
        }
        for (const arg of ol.stackArgs) {
          yield* emitArg(arg)
        }
        yield `):`
        yield* emitReturnTypes(ol.returnTypes)
        yield* noImplementation()
        yield ',\n'
      }

      yield `}\n`
    }
    yield `\n`
  }
}
