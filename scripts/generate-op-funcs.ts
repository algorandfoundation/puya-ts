import { camelCase } from 'change-case'
import { distinct, enumerate, hasFlags } from '../src/util'
import type { OpArg, OpModule, OpOverloadedFunction } from './build-op-module'
import { AlgoTsType, ENUMS_TO_EXPOSE } from './build-op-module'

export function* emitOpFuncTypes(module: OpModule) {
  function* emitHeader() {
    yield `/* THIS FILE IS GENERATED BY ~/scripts/generate-op-funcs.ts - DO NOT MODIFY DIRECTLY */
import { NoImplementation } from "./impl/errors";
import { bytes, uint64, biguint } from './primitives'
import { Account, Application, Asset } from './reference'

`
  }
  function* noImplementation() {
    yield '{'
    yield `throw new NoImplementation()`
    yield '}'
  }

  function* emitDoc(doc: string | string[], minAvmVersion?: number) {
    if (Array.isArray(doc)) {
      yield '\n/**'
      for (const row of doc) {
        yield '\n  * '
        yield row
      }
    } else if (doc) {
      yield '\n/**'
      yield '\n  * '
      yield doc
    } else {
      return
    }
    if (minAvmVersion !== undefined) yield `\n  * Min AVM version: ${minAvmVersion}`
    yield '\n  */'
    yield '\n'
  }
  function* emitEnums() {
    for (const enumDef of module.enums) {
      if (!ENUMS_TO_EXPOSE.has(enumDef.name)) continue

      yield `export enum ${enumDef.tsName} {`
      for (const member of enumDef.members) {
        yield* emitDoc(member.doc)
        yield `${member.name} = '${member.value}',`
      }

      yield `}\n`
    }
  }

  function* emitReturnType(returnType: AlgoTsType) {
    if (hasFlags(returnType, AlgoTsType.Application)) yield 'Application'
    if (hasFlags(returnType, AlgoTsType.Account)) yield 'Account'
    if (hasFlags(returnType, AlgoTsType.Asset)) yield 'Asset'
    if (hasFlags(returnType, AlgoTsType.Uint64)) yield 'uint64'
    if (hasFlags(returnType, AlgoTsType.Bytes)) yield 'bytes'
    if (hasFlags(returnType, AlgoTsType.String)) yield 'string'
    if (hasFlags(returnType, AlgoTsType.Boolean)) yield 'boolean'
    if (hasFlags(returnType, AlgoTsType.BigUint)) yield 'biguint'
    if (hasFlags(returnType, AlgoTsType.Void)) yield 'void'
    if (hasFlags(returnType, AlgoTsType.Enum)) {
      for (const enumDef of module.enums.filter((a) => hasFlags(a.typeFlag, returnType))) {
        yield enumDef.tsName
      }
    }
  }
  function* emitReturnTypes(returnTypes: AlgoTsType[]) {
    switch (returnTypes.length) {
      case 0:
        yield 'void'
        break
      case 1:
        yield Array.from(emitReturnType(returnTypes[0])).join(' | ')
        break
      default:
        yield 'readonly ['
        for (const rt of returnTypes) {
          yield Array.from(emitReturnType(rt)).join(' | ')
          yield ','
        }
        yield ']'
        break
    }
  }
  function* emitArgType(argType: AlgoTsType) {
    if (hasFlags(argType, AlgoTsType.Application)) yield 'Application'
    if (hasFlags(argType, AlgoTsType.Account)) yield 'Account'
    if (hasFlags(argType, AlgoTsType.Asset)) yield 'Asset'
    if (hasFlags(argType, AlgoTsType.Uint64)) yield 'uint64'
    if (hasFlags(argType, AlgoTsType.Bytes)) yield 'bytes'
    if (hasFlags(argType, AlgoTsType.String)) yield 'string'
    if (hasFlags(argType, AlgoTsType.Boolean)) yield 'boolean'
    if (hasFlags(argType, AlgoTsType.BigUint)) yield 'biguint'
    if (hasFlags(argType, AlgoTsType.Void)) yield 'void'
    if (hasFlags(argType, AlgoTsType.Enum)) {
      for (const enumDef of module.enums.filter((a) => hasFlags(argType, a.typeFlag))) {
        yield enumDef.tsName
      }
    }
  }
  function* emitArg(arg: OpArg) {
    yield arg.name
    if (arg.optional) {
      yield '?'
    }
    yield ':'
    yield Array.from(emitArgType(arg.type)).join(' | ')
    yield ','
  }

  function combineReturnTypes(op: OpOverloadedFunction): string {
    return op.signatures
      .map((s) => Array.from(emitReturnTypes(s.returnTypes)).join(''))
      .filter(distinct())
      .join(' | ')
  }

  yield* emitHeader()

  yield* emitEnums()

  for (const item of module.items) {
    if (item.type === 'op-function') {
      yield* emitDoc(item.docs, item.minAvmVersion)
      yield `export function ${camelCase(item.name)}(`
      for (const arg of item.immediateArgs) {
        yield* emitArg(arg)
      }
      for (const arg of item.stackArgs) {
        yield* emitArg(arg)
      }
      yield `): `
      yield* emitReturnTypes(item.returnTypes)
      yield* noImplementation()
    } else if (item.type === 'op-overloaded-function') {
      for (const signature of item.signatures) {
        yield* emitDoc(signature.docs)
        yield `export function ${camelCase(item.name)}(`
        for (const arg of signature.immediateArgs) {
          yield* emitArg(arg)
        }
        for (const arg of signature.stackArgs) {
          yield* emitArg(arg)
        }
        yield `): `
        yield* emitReturnTypes(signature.returnTypes)
        yield '\n'
      }
      yield `export function ${camelCase(item.name)}(`
      const args = item.signatures
        .map((s) => s.immediateArgs.concat(s.stackArgs))
        .reduce((acc, cur) =>
          new Array(Math.max(acc.length, cur.length)).fill(null).map((_, i): OpArg => {
            const left = acc[i]
            const right = cur[i]
            return left
              ? right
                ? {
                    name: left.name,
                    type: left.type | right.type,
                  }
                : {
                    ...left,
                    optional: true,
                  }
              : {
                  ...right,
                  optional: true,
                }
          }),
        )
      for (const arg of args) {
        yield* emitArg(arg)
      }
      yield '): '
      yield combineReturnTypes(item)
      yield* noImplementation()
    } else {
      yield* emitDoc(item.docs)

      yield `export const ${item.name} = {`

      for (const ol of Object.values(item.functions)) {
        yield '\n'
        yield* emitDoc(ol.docs, ol.minAvmVersion)
        if (ol.stackArgs.length === 0 && ol.immediateArgs.length === 1) {
          yield 'get '
        }
        yield `${ol.name}(`
        for (const [index, arg] of enumerate(ol.immediateArgs)) {
          if (index === ol.enumArg?.pos) continue

          yield* emitArg(arg)
        }
        for (const arg of ol.stackArgs) {
          yield* emitArg(arg)
        }
        yield `):`
        yield* emitReturnTypes(ol.returnTypes)
        yield* noImplementation()
        yield ',\n'
      }

      yield `}\n`
    }
    yield `\n`
  }
}
