/* THIS FILE IS GENERATED BY ~/scripts/generate-op.ts - DO NOT MODIFY DIRECTLY */
import { createFunctionProxy, createObjectProxy } from './op-util'
import {
  AcctParamsType,
  AddwType,
  AppGlobalType,
  AppLocalType,
  AppOptedInType,
  AppParamsType,
  ArgType,
  AssetHoldingType,
  AssetParamsType,
  BalanceType,
  Base64DecodeType,
  BitLengthType,
  BlockType,
  BoxType,
  BsqrtType,
  BtoiType,
  BzeroType,
  ConcatType,
  DivmodwType,
  DivwType,
  EllipticCurveType,
  EcdsaPkDecompressType,
  EcdsaPkRecoverType,
  EcdsaVerifyType,
  Ed25519verifyType,
  Ed25519verifyBareType,
  ExpType,
  ExpwType,
  ExtractUint16Type,
  ExtractUint32Type,
  ExtractUint64Type,
  FalconVerifyType,
  GaidType,
  GetBitType,
  GetByteType,
  GITxnType,
  GloadBytesType,
  GloadUint64Type,
  GlobalType,
  GTxnType,
  ItobType,
  ITxnType,
  ITxnCreateType,
  JsonRefType,
  Keccak256Type,
  LenType,
  ScratchType,
  MimcType,
  MinBalanceType,
  MulwType,
  OnlineStakeType,
  ReplaceType,
  SetByteType,
  Sha256Type,
  Sha3_256Type,
  Sha512_256Type,
  ShlType,
  ShrType,
  SqrtType,
  SubstringType,
  Sumhash512Type,
  TxnType,
  VoterParamsType,
  VrfVerifyType,
  ExtractType,
  SelectType,
  SetBitType,
} from './op-types'

export const AcctParams: AcctParamsType = createObjectProxy('AcctParams')

/**
 * A plus B as a 128-bit result. X is the carry-bit, Y is the low-order 64 bits.
 * @see Native TEAL opcode: [`addw`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#addw)
 * Min AVM version: 2
 */
export const addw: AddwType = createFunctionProxy('addw')

/**
 * Get or modify Global app state
 */
export const AppGlobal: AppGlobalType = createObjectProxy('AppGlobal')

/**
 * Get or modify Local app state
 */
export const AppLocal: AppLocalType = createObjectProxy('AppLocal')

/**
 * 1 if account A is opted in to application B, else 0
 * @param Txn.Accounts offset (or, since v4, an _available_ account address), _available_ application id (or, since v4, a Txn.ForeignApps offset).
 *  * @return 1 if opted in and 0 otherwise.
 * @see Native TEAL opcode: [`app_opted_in`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#app_opted_in)
 * Min AVM version: 2
 */
export const appOptedIn: AppOptedInType = createFunctionProxy('appOptedIn')
export const AppParams: AppParamsType = createObjectProxy('AppParams')

/**
 * Ath LogicSig argument
 * @see Native TEAL opcode: [`args`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#args)
 * Min AVM version: 5
 */
export const arg: ArgType = createFunctionProxy('arg')
export const AssetHolding: AssetHoldingType = createObjectProxy('AssetHolding')
export const AssetParams: AssetParamsType = createObjectProxy('AssetParams')

/**
 * balance for account A, in microalgos. The balance is observed after the effects of previous transactions in the group, and after the fee for the current transaction is deducted. Changes caused by inner transactions are observable immediately following `itxn_submit`
 * @param Txn.Accounts offset (or, since v4, an _available_ account address), _available_ application id (or, since v4, a Txn.ForeignApps offset).
 *  * @return value.
 * @see Native TEAL opcode: [`balance`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#balance)
 * Min AVM version: 2
 */
export const balance: BalanceType = createFunctionProxy('balance')

/**
 * decode A which was base64-encoded using _encoding_ E. Fail if A is not base64 encoded with encoding E
 * *Warning*: Usage should be restricted to very rare use cases. In almost all cases, smart contracts should directly handle non-encoded byte-strings.	This opcode should only be used in cases where base64 is the only available option, e.g. interoperability with a third-party that only signs base64 strings.
 *  Decodes A using the base64 encoding E. Specify the encoding with an immediate arg either as URL and Filename Safe (`URLEncoding`) or Standard (`StdEncoding`). See [RFC 4648 sections 4 and 5](https://rfc-editor.org/rfc/rfc4648.html#section-4). It is assumed that the encoding ends with the exact number of `=` padding characters as required by the RFC. When padding occurs, any unused pad bits in the encoding must be set to zero or the decoding will fail. The special cases of `\n` and `\r` are allowed but completely ignored. An error will result when attempting to decode a string with a character that is not in the encoding alphabet or not one of `=`, `\r`, or `\n`.
 * @see Native TEAL opcode: [`base64_decode`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#base64_decode)
 * Min AVM version: 7
 */
export const base64Decode: Base64DecodeType = createFunctionProxy('base64Decode')

/**
 * The highest set bit in A. If A is a byte-array, it is interpreted as a big-endian unsigned integer. bitlen of 0 is 0, bitlen of 8 is 4
 * bitlen interprets arrays as big-endian integers, unlike setbit/getbit
 * @see Native TEAL opcode: [`bitlen`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#bitlen)
 * Min AVM version: 4
 */
export const bitLength: BitLengthType = createFunctionProxy('bitLength')
export const Block: BlockType = createObjectProxy('Block')

/**
 * Get or modify box state
 */
export const Box: BoxType = createObjectProxy('Box')

/**
 * The largest integer I such that I^2 <= A. A and I are interpreted as big-endian unsigned integers
 * @see Native TEAL opcode: [`bsqrt`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#bsqrt)
 * Min AVM version: 6
 */
export const bsqrt: BsqrtType = createFunctionProxy('bsqrt')

/**
 * converts big-endian byte array A to uint64. Fails if len(A) > 8. Padded by leading 0s if len(A) < 8.
 * `btoi` fails if the input is longer than 8 bytes.
 * @see Native TEAL opcode: [`btoi`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#btoi)
 * Min AVM version: 1
 */
export const btoi: BtoiType = createFunctionProxy('btoi')

/**
 * zero filled byte-array of length A
 * @see Native TEAL opcode: [`bzero`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#bzero)
 * Min AVM version: 4
 */
export const bzero: BzeroType = createFunctionProxy('bzero')

/**
 * join A and B
 * `concat` fails if the result would be greater than 4096 bytes.
 * @see Native TEAL opcode: [`concat`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#concat)
 * Min AVM version: 2
 */
export const concat: ConcatType = createFunctionProxy('concat')

/**
 * W,X = (A,B / C,D); Y,Z = (A,B modulo C,D)
 * The notation J,K indicates that two uint64 values J and K are interpreted as a uint128 value, with J as the high uint64 and K the low.
 * @see Native TEAL opcode: [`divmodw`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#divmodw)
 * Min AVM version: 4
 */
export const divmodw: DivmodwType = createFunctionProxy('divmodw')

/**
 * A,B / C. Fail if C == 0 or if result overflows.
 * The notation A,B indicates that A and B are interpreted as a uint128 value, with A as the high uint64 and B the low.
 * @see Native TEAL opcode: [`divw`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#divw)
 * Min AVM version: 6
 */
export const divw: DivwType = createFunctionProxy('divw')

/**
 * Elliptic Curve functions
 */
export const EllipticCurve: EllipticCurveType = createObjectProxy('EllipticCurve')

/**
 * decompress pubkey A into components X, Y
 * The 33 byte public key in a compressed form to be decompressed into X and Y (top) components. All values are big-endian encoded.
 * @see Native TEAL opcode: [`ecdsa_pk_decompress`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#ecdsa_pk_decompress)
 * Min AVM version: 5
 */
export const ecdsaPkDecompress: EcdsaPkDecompressType = createFunctionProxy('ecdsaPkDecompress')

/**
 * for (data A, recovery id B, signature C, D) recover a public key
 * S (top) and R elements of a signature, recovery id and data (bottom) are expected on the stack and used to deriver a public key. All values are big-endian encoded. The signed data must be 32 bytes long.
 * @see Native TEAL opcode: [`ecdsa_pk_recover`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#ecdsa_pk_recover)
 * Min AVM version: 5
 */
export const ecdsaPkRecover: EcdsaPkRecoverType = createFunctionProxy('ecdsaPkRecover')

/**
 * for (data A, signature B, C and pubkey D, E) verify the signature of the data against the pubkey => {0 or 1}
 * The 32 byte Y-component of a public key is the last element on the stack, preceded by X-component of a pubkey, preceded by S and R components of a signature, preceded by the data that is fifth element on the stack. All values are big-endian encoded. The signed data must be 32 bytes long, and signatures in lower-S form are only accepted.
 * @see Native TEAL opcode: [`ecdsa_verify`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#ecdsa_verify)
 * Min AVM version: 5
 */
export const ecdsaVerify: EcdsaVerifyType = createFunctionProxy('ecdsaVerify')

/**
 * for (data A, signature B, pubkey C) verify the signature of ("ProgData" || program_hash || data) against the pubkey => {0 or 1}
 * The 32 byte public key is the last element on the stack, preceded by the 64 byte signature at the second-to-last element on the stack, preceded by the data which was signed at the third-to-last element on the stack.
 * @see Native TEAL opcode: [`ed25519verify`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#ed25519verify)
 * Min AVM version: 1
 */
export const ed25519verify: Ed25519verifyType = createFunctionProxy('ed25519verify')

/**
 * for (data A, signature B, pubkey C) verify the signature of the data against the pubkey => {0 or 1}
 * @see Native TEAL opcode: [`ed25519verify_bare`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#ed25519verify_bare)
 * Min AVM version: 7
 */
export const ed25519verifyBare: Ed25519verifyBareType = createFunctionProxy('ed25519verifyBare')

/**
 * A raised to the Bth power. Fail if A == B == 0 and on overflow
 * @see Native TEAL opcode: [`exp`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#exp)
 * Min AVM version: 4
 */
export const exp: ExpType = createFunctionProxy('exp')

/**
 * A raised to the Bth power as a 128-bit result in two uint64s. X is the high 64 bits, Y is the low. Fail if A == B == 0 or if the results exceeds 2^128-1
 * @see Native TEAL opcode: [`expw`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#expw)
 * Min AVM version: 4
 */
export const expw: ExpwType = createFunctionProxy('expw')

/**
 * A uint16 formed from a range of big-endian bytes from A starting at B up to but not including B+2. If B+2 is larger than the array length, the program fails
 * @see Native TEAL opcode: [`extract_uint16`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#extract_uint16)
 * Min AVM version: 5
 */
export const extractUint16: ExtractUint16Type = createFunctionProxy('extractUint16')

/**
 * A uint32 formed from a range of big-endian bytes from A starting at B up to but not including B+4. If B+4 is larger than the array length, the program fails
 * @see Native TEAL opcode: [`extract_uint32`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#extract_uint32)
 * Min AVM version: 5
 */
export const extractUint32: ExtractUint32Type = createFunctionProxy('extractUint32')

/**
 * A uint64 formed from a range of big-endian bytes from A starting at B up to but not including B+8. If B+8 is larger than the array length, the program fails
 * @see Native TEAL opcode: [`extract_uint64`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#extract_uint64)
 * Min AVM version: 5
 */
export const extractUint64: ExtractUint64Type = createFunctionProxy('extractUint64')

/**
 * for (data A, compressed-format signature B, pubkey C) verify the signature of data against the pubkey
 * @see Native TEAL opcode: [`falcon_verify`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#falcon_verify)
 * Min AVM version: 12
 */
export const falconVerify: FalconVerifyType = createFunctionProxy('falconVerify')

/**
 * ID of the asset or application created in the Ath transaction of the current group
 * `gaids` fails unless the requested transaction created an asset or application and A < GroupIndex.
 * @see Native TEAL opcode: [`gaids`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gaids)
 * Min AVM version: 4
 */
export const gaid: GaidType = createFunctionProxy('gaid')

/**
 * Bth bit of (byte-array or integer) A. If B is greater than or equal to the bit length of the value (8*byte length), the program fails
 * see explanation of bit ordering in setbit
 * @see Native TEAL opcode: [`getbit`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#getbit)
 * Min AVM version: 3
 */
export const getBit: GetBitType = createFunctionProxy('getBit')

/**
 * Bth byte of A, as an integer. If B is greater than or equal to the array length, the program fails
 * @see Native TEAL opcode: [`getbyte`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#getbyte)
 * Min AVM version: 3
 */
export const getByte: GetByteType = createFunctionProxy('getByte')

/**
 * Get values for inner transaction in the last group submitted
 */
export const GITxn: GITxnType = createObjectProxy('GITxn')

/**
 * Bth scratch space value of the Ath transaction in the current group
 * @see Native TEAL opcode: [`gloadss`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gloadss)
 * Min AVM version: 6
 */
export const gloadBytes: GloadBytesType = createFunctionProxy('gloadBytes')

/**
 * Bth scratch space value of the Ath transaction in the current group
 * @see Native TEAL opcode: [`gloadss`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#gloadss)
 * Min AVM version: 6
 */
export const gloadUint64: GloadUint64Type = createFunctionProxy('gloadUint64')
export const Global: GlobalType = createObjectProxy('Global')

/**
 * Get values for transactions in the current group
 */
export const GTxn: GTxnType = createObjectProxy('GTxn')

/**
 * converts uint64 A to big-endian byte array, always of length 8
 * @see Native TEAL opcode: [`itob`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#itob)
 * Min AVM version: 1
 */
export const itob: ItobType = createFunctionProxy('itob')

/**
 * Get values for the last inner transaction
 */
export const ITxn: ITxnType = createObjectProxy('ITxn')

/**
 * Create inner transactions
 */
export const ITxnCreate: ITxnCreateType = createObjectProxy('ITxnCreate')
export const JsonRef: JsonRefType = createObjectProxy('JsonRef')

/**
 * Keccak256 hash of value A, yields [32]byte
 * @see Native TEAL opcode: [`keccak256`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#keccak256)
 * Min AVM version: 1
 */
export const keccak256: Keccak256Type = createFunctionProxy('keccak256')

/**
 * yields length of byte value A
 * @see Native TEAL opcode: [`len`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#len)
 * Min AVM version: 1
 */
export const len: LenType = createFunctionProxy('len')

/**
 * Load or store scratch values
 */
export const Scratch: ScratchType = createObjectProxy('Scratch')

/**
 * MiMC hash of scalars A, using curve and parameters specified by configuration C
 * A is a list of concatenated 32 byte big-endian unsigned integer scalars.  Fail if A's length is not a multiple of 32 or any element exceeds the curve modulus.
 * The MiMC hash function has known collisions since any input which is a multiple of the elliptic curve modulus will hash to the same value. MiMC is thus not a general purpose hash function, but meant to be used in zero knowledge applications to match a zk-circuit implementation.
 * @see Native TEAL opcode: [`mimc`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#mimc)
 * Min AVM version: 11
 */
export const mimc: MimcType = createFunctionProxy('mimc')

/**
 * minimum required balance for account A, in microalgos. Required balance is affected by ASA, App, and Box usage. When creating or opting into an app, the minimum balance grows before the app code runs, therefore the increase is visible there. When deleting or closing out, the minimum balance decreases after the app executes. Changes caused by inner transactions or box usage are observable immediately following the opcode effecting the change.
 * @param Txn.Accounts offset (or, since v4, an _available_ account address), _available_ application id (or, since v4, a Txn.ForeignApps offset).
 *  * @return value.
 * @see Native TEAL opcode: [`min_balance`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#min_balance)
 * Min AVM version: 3
 */
export const minBalance: MinBalanceType = createFunctionProxy('minBalance')

/**
 * A times B as a 128-bit result in two uint64s. X is the high 64 bits, Y is the low
 * @see Native TEAL opcode: [`mulw`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#mulw)
 * Min AVM version: 1
 */
export const mulw: MulwType = createFunctionProxy('mulw')

/**
 * the total online stake in the agreement round
 * @see Native TEAL opcode: [`online_stake`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#online_stake)
 * Min AVM version: 11
 */
export const onlineStake: OnlineStakeType = createFunctionProxy('onlineStake')

/**
 * Copy of A with the bytes starting at B replaced by the bytes of C. Fails if B+len(C) exceeds len(A)
 * `replace3` can be called using `replace` with no immediates.
 * @see Native TEAL opcode: [`replace3`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#replace3)
 * Min AVM version: 7
 */
export const replace: ReplaceType = createFunctionProxy('replace')

/**
 * Copy of A with the Bth byte set to small integer (between 0..255) C. If B is greater than or equal to the array length, the program fails
 * @see Native TEAL opcode: [`setbyte`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#setbyte)
 * Min AVM version: 3
 */
export const setByte: SetByteType = createFunctionProxy('setByte')

/**
 * SHA256 hash of value A, yields [32]byte
 * @see Native TEAL opcode: [`sha256`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#sha256)
 * Min AVM version: 1
 */
export const sha256: Sha256Type = createFunctionProxy('sha256')

/**
 * SHA3_256 hash of value A, yields [32]byte
 * @see Native TEAL opcode: [`sha3_256`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#sha3_256)
 * Min AVM version: 7
 */
export const sha3_256: Sha3_256Type = createFunctionProxy('sha3_256')

/**
 * SHA512_256 hash of value A, yields [32]byte
 * @see Native TEAL opcode: [`sha512_256`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#sha512_256)
 * Min AVM version: 1
 */
export const sha512_256: Sha512_256Type = createFunctionProxy('sha512_256')

/**
 * A times 2^B, modulo 2^64
 * @see Native TEAL opcode: [`shl`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#shl)
 * Min AVM version: 4
 */
export const shl: ShlType = createFunctionProxy('shl')

/**
 * A divided by 2^B
 * @see Native TEAL opcode: [`shr`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#shr)
 * Min AVM version: 4
 */
export const shr: ShrType = createFunctionProxy('shr')

/**
 * The largest integer I such that I^2 <= A
 * @see Native TEAL opcode: [`sqrt`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#sqrt)
 * Min AVM version: 4
 */
export const sqrt: SqrtType = createFunctionProxy('sqrt')

/**
 * A range of bytes from A starting at B up to but not including C. If C < B, or either is larger than the array length, the program fails
 * @see Native TEAL opcode: [`substring3`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#substring3)
 * Min AVM version: 2
 */
export const substring: SubstringType = createFunctionProxy('substring')

/**
 * sumhash512 of value A, yields [64]byte
 * @see Native TEAL opcode: [`sumhash512`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#sumhash512)
 * Min AVM version: 12
 */
export const sumhash512: Sumhash512Type = createFunctionProxy('sumhash512')

/**
 * Get values for the current executing transaction
 */
export const Txn: TxnType = createObjectProxy('Txn')
export const VoterParams: VoterParamsType = createObjectProxy('VoterParams')

/**
 * Verify the proof B of message A against pubkey C. Returns vrf output and verification flag.
 * `VrfAlgorand` is the VRF used in Algorand. It is ECVRF-ED25519-SHA512-Elligator2, specified in the IETF internet draft [draft-irtf-cfrg-vrf-03](https://datatracker.ietf.org/doc/draft-irtf-cfrg-vrf/03/).
 * @see Native TEAL opcode: [`vrf_verify`](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v10/#vrf_verify)
 * Min AVM version: 7
 */
export const vrfVerify: VrfVerifyType = createFunctionProxy('vrfVerify')
export const extract: ExtractType = createFunctionProxy('extract') as ExtractType
export const select: SelectType = createFunctionProxy('select') as SelectType
export const setBit: SetBitType = createFunctionProxy('setBit') as SetBitType
