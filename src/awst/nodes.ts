/* AUTOGENERATED FILE - DO NOT EDIT (see puya/scripts/generate_ts_nodes.py) */
import type * as wtypes from './wtypes'
import type { SourceLocation } from './source-location'
import type { ARC4BareMethodConfig, ARC4ABIMethodConfig, ContractReference, LogicSigReference } from './models'
import type { Props } from '../typescript-helpers'
export enum TxnField {
  sender,
  fee,
  firstValid,
  firstValidTime,
  lastValid,
  note,
  lease,
  receiver,
  amount,
  closeRemainderTo,
  votePK,
  selectionPK,
  voteFirst,
  voteLast,
  voteKeyDilution,
  type,
  typeEnum,
  xferAsset,
  assetAmount,
  assetSender,
  assetReceiver,
  assetCloseTo,
  groupIndex,
  txID,
  applicationID,
  onCompletion,
  numAppArgs,
  numAccounts,
  approvalProgram,
  clearStateProgram,
  rekeyTo,
  configAsset,
  configAssetTotal,
  configAssetDecimals,
  configAssetDefaultFrozen,
  configAssetUnitName,
  configAssetName,
  configAssetURL,
  configAssetMetadataHash,
  configAssetManager,
  configAssetReserve,
  configAssetFreeze,
  configAssetClawback,
  freezeAsset,
  freezeAssetAccount,
  freezeAssetFrozen,
  numAssets,
  numApplications,
  globalNumUint,
  globalNumByteSlice,
  localNumUint,
  localNumByteSlice,
  extraProgramPages,
  nonparticipation,
  numLogs,
  createdAssetID,
  createdApplicationID,
  lastLog,
  stateProofPK,
  numApprovalProgramPages,
  numClearStateProgramPages,
  applicationArgs,
  accounts,
  assets,
  applications,
  logs,
  approvalProgramPages,
  clearStateProgramPages,
}
export abstract class Node {
  protected constructor(props: Props<Node>) {
    this.sourceLocation = props.sourceLocation
  }
  sourceLocation: SourceLocation
}
export abstract class Statement extends Node {
  protected constructor(props: Props<Statement>) {
    super(props)
  }
  abstract accept<T>(visitor: StatementVisitor<T>): T
}
export abstract class Expression extends Node {
  protected constructor(props: Props<Expression>) {
    super(props)
    this.wtype = props.wtype
  }
  wtype: wtypes.WType
  abstract accept<T>(visitor: ExpressionVisitor<T>): T
}
export class ExpressionStatement extends Statement {
  constructor(props: Props<ExpressionStatement>) {
    super(props)
    this.expr = props.expr
  }
  expr: Expression
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitExpressionStatement(this)
  }
}
export class Block extends Statement {
  constructor(props: Props<Block>) {
    super(props)
    this.body = props.body
    this.label = props.label
    this.comment = props.comment
  }
  body: Array<Statement>
  label?: string | undefined
  comment?: string | undefined
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitBlock(this)
  }
}
export class Goto extends Statement {
  constructor(props: Props<Goto>) {
    super(props)
    this.target = props.target
  }
  target: string
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitGoto(this)
  }
}
export class IfElse extends Statement {
  constructor(props: Props<IfElse>) {
    super(props)
    this.condition = props.condition
    this.ifBranch = props.ifBranch
    this.elseBranch = props.elseBranch
  }
  condition: Expression
  ifBranch: Block
  elseBranch?: Block | undefined
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitIfElse(this)
  }
}
export class Switch extends Statement {
  constructor(props: Props<Switch>) {
    super(props)
    this.value = props.value
    this.cases = props.cases
    this.defaultCase = props.defaultCase
  }
  value: Expression
  cases: Map<Expression, Block>
  defaultCase?: Block | undefined
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitSwitch(this)
  }
}
export class WhileLoop extends Statement {
  constructor(props: Props<WhileLoop>) {
    super(props)
    this.condition = props.condition
    this.loopBody = props.loopBody
  }
  condition: Expression
  loopBody: Block
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitWhileLoop(this)
  }
}
export class LoopExit extends Statement {
  constructor(props: Props<LoopExit>) {
    super(props)
  }
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitLoopExit(this)
  }
}
export class LoopContinue extends Statement {
  constructor(props: Props<LoopContinue>) {
    super(props)
  }
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitLoopContinue(this)
  }
}
export class ReturnStatement extends Statement {
  constructor(props: Props<ReturnStatement>) {
    super(props)
    this.value = props.value
  }
  value?: Expression | undefined
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitReturnStatement(this)
  }
}
export class IntegerConstant extends Expression {
  constructor(props: Props<IntegerConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
    this.tealAlias = props.tealAlias
  }
  value: bigint
  tealAlias?: string | undefined
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitIntegerConstant(this)
  }
}
export class DecimalConstant extends Expression {
  constructor(props: Props<DecimalConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
  }
  declare wtype: wtypes.ARC4UFixedNxM
  value: number
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitDecimalConstant(this)
  }
}
export class BoolConstant extends Expression {
  constructor(props: Props<BoolConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
  }
  value: boolean
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBoolConstant(this)
  }
}
export enum BytesEncoding {
  unknown = 'unknown',
  base16 = 'base16',
  base32 = 'base32',
  base64 = 'base64',
  utf8 = 'utf8',
}
export class BytesConstant extends Expression {
  constructor(props: Props<BytesConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
    this.encoding = props.encoding
  }
  value: Uint8Array
  encoding: BytesEncoding
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBytesConstant(this)
  }
}
export class StringConstant extends Expression {
  constructor(props: Props<StringConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
  }
  value: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitStringConstant(this)
  }
}
export class TemplateVar extends Expression {
  constructor(props: Props<TemplateVar>) {
    super(props)
    this.wtype = props.wtype
    this.name = props.name
  }
  name: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitTemplateVar(this)
  }
}
export class MethodConstant extends Expression {
  constructor(props: Props<MethodConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
  }
  value: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitMethodConstant(this)
  }
}
export class AddressConstant extends Expression {
  constructor(props: Props<AddressConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
  }
  value: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitAddressConstant(this)
  }
}
export class ARC4Encode extends Expression {
  constructor(props: Props<ARC4Encode>) {
    super(props)
    this.value = props.value
    this.wtype = props.wtype
  }
  value: Expression
  declare wtype: wtypes.ARC4Type
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitARC4Encode(this)
  }
}
export class Copy extends Expression {
  constructor(props: Props<Copy>) {
    super(props)
    this.value = props.value
    this.wtype = props.wtype
  }
  value: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitCopy(this)
  }
}
export class ArrayConcat extends Expression {
  constructor(props: Props<ArrayConcat>) {
    super(props)
    this.left = props.left
    this.right = props.right
  }
  left: Expression
  right: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitArrayConcat(this)
  }
}
export class ArrayPop extends Expression {
  constructor(props: Props<ArrayPop>) {
    super(props)
    this.base = props.base
  }
  base: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitArrayPop(this)
  }
}
export class ArrayExtend extends Expression {
  constructor(props: Props<ArrayExtend>) {
    super(props)
    this.base = props.base
    this.other = props.other
  }
  base: Expression
  other: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitArrayExtend(this)
  }
}
export class ARC4Decode extends Expression {
  constructor(props: Props<ARC4Decode>) {
    super(props)
    this.value = props.value
  }
  value: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitARC4Decode(this)
  }
}
export class IntrinsicCall extends Expression {
  constructor(props: Props<IntrinsicCall>) {
    super(props)
    this.opCode = props.opCode
    this.immediates = props.immediates
    this.stackArgs = props.stackArgs
    this.comment = props.comment
  }
  opCode: string
  immediates: Array<string | bigint>
  stackArgs: Array<Expression>
  comment?: string | undefined
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitIntrinsicCall(this)
  }
}
export class CreateInnerTransaction extends Expression {
  constructor(props: Props<CreateInnerTransaction>) {
    super(props)
    this.wtype = props.wtype
    this.fields = props.fields
  }
  declare wtype: wtypes.WInnerTransactionFields
  fields: Map<TxnField, Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitCreateInnerTransaction(this)
  }
}
export class UpdateInnerTransaction extends Expression {
  constructor(props: Props<UpdateInnerTransaction>) {
    super(props)
    this.itxn = props.itxn
    this.fields = props.fields
    this.wtype = props.wtype
  }
  itxn: Expression
  fields: Map<TxnField, Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitUpdateInnerTransaction(this)
  }
}
export class CheckedMaybe extends Expression {
  constructor(props: Props<CheckedMaybe>) {
    super(props)
    this.expr = props.expr
    this.comment = props.comment
  }
  expr: Expression
  comment: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitCheckedMaybe(this)
  }
}
export class TupleExpression extends Expression {
  constructor(props: Props<TupleExpression>) {
    super(props)
    this.items = props.items
    this.wtype = props.wtype
  }
  items: Array<Expression>
  declare wtype: wtypes.WTuple
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitTupleExpression(this)
  }
}
export class TupleItemExpression extends Expression {
  constructor(props: Props<TupleItemExpression>) {
    super(props)
    this.base = props.base
    this.index = props.index
  }
  base: Expression
  index: bigint
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitTupleItemExpression(this)
  }
}
export class VarExpression extends Expression {
  constructor(props: Props<VarExpression>) {
    super(props)
    this.name = props.name
  }
  name: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitVarExpression(this)
  }
}
export class InnerTransactionField extends Expression {
  constructor(props: Props<InnerTransactionField>) {
    super(props)
    this.itxn = props.itxn
    this.field = props.field
    this.arrayIndex = props.arrayIndex
  }
  itxn: Expression
  field: TxnField
  arrayIndex?: Expression | undefined
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitInnerTransactionField(this)
  }
}
export class SubmitInnerTransaction extends Expression {
  constructor(props: Props<SubmitInnerTransaction>) {
    super(props)
    this.group = props.group
    this.wtype = props.wtype
  }
  group: Expression | [Expression]
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitSubmitInnerTransaction(this)
  }
}
export class FieldExpression extends Expression {
  constructor(props: Props<FieldExpression>) {
    super(props)
    this.base = props.base
    this.name = props.name
    this.wtype = props.wtype
  }
  base: Expression
  name: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitFieldExpression(this)
  }
}
export class IndexExpression extends Expression {
  constructor(props: Props<IndexExpression>) {
    super(props)
    this.base = props.base
    this.index = props.index
  }
  base: Expression
  index: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitIndexExpression(this)
  }
}
export class SliceExpression extends Expression {
  constructor(props: Props<SliceExpression>) {
    super(props)
    this.base = props.base
    this.beginIndex = props.beginIndex
    this.endIndex = props.endIndex
  }
  base: Expression
  beginIndex?: Expression | undefined
  endIndex?: Expression | undefined
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitSliceExpression(this)
  }
}
export class IntersectionSliceExpression extends Expression {
  constructor(props: Props<IntersectionSliceExpression>) {
    super(props)
    this.base = props.base
    this.beginIndex = props.beginIndex
    this.endIndex = props.endIndex
  }
  base: Expression
  beginIndex?: Expression | bigint | undefined
  endIndex?: Expression | bigint | undefined
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitIntersectionSliceExpression(this)
  }
}
export class AppStateExpression extends Expression {
  constructor(props: Props<AppStateExpression>) {
    super(props)
    this.key = props.key
    this.existsAssertionMessage = props.existsAssertionMessage
  }
  key: Expression
  existsAssertionMessage?: string | undefined
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitAppStateExpression(this)
  }
}
export class AppAccountStateExpression extends Expression {
  constructor(props: Props<AppAccountStateExpression>) {
    super(props)
    this.key = props.key
    this.existsAssertionMessage = props.existsAssertionMessage
    this.account = props.account
  }
  key: Expression
  existsAssertionMessage?: string | undefined
  account: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitAppAccountStateExpression(this)
  }
}
export class BoxValueExpression extends Expression {
  constructor(props: Props<BoxValueExpression>) {
    super(props)
    this.key = props.key
    this.existsAssertionMessage = props.existsAssertionMessage
  }
  key: Expression
  existsAssertionMessage?: string | undefined
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBoxValueExpression(this)
  }
}
export class SingleEvaluation extends Expression {
  constructor(props: Props<SingleEvaluation>) {
    super(props)
    this.source = props.source
    this.id = props.id
  }
  source: Expression
  id: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitSingleEvaluation(this)
  }
}
export class ReinterpretCast extends Expression {
  constructor(props: Props<ReinterpretCast>) {
    super(props)
    this.expr = props.expr
  }
  expr: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitReinterpretCast(this)
  }
}
export class NewArray extends Expression {
  constructor(props: Props<NewArray>) {
    super(props)
    this.wtype = props.wtype
    this.values = props.values
  }
  declare wtype: wtypes.WArray | wtypes.ARC4Array
  values: Array<Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitNewArray(this)
  }
}
export class ConditionalExpression extends Expression {
  constructor(props: Props<ConditionalExpression>) {
    super(props)
    this.condition = props.condition
    this.trueExpr = props.trueExpr
    this.falseExpr = props.falseExpr
    this.wtype = props.wtype
  }
  condition: Expression
  trueExpr: Expression
  falseExpr: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitConditionalExpression(this)
  }
}
export class AssignmentStatement extends Statement {
  constructor(props: Props<AssignmentStatement>) {
    super(props)
    this.target = props.target
    this.value = props.value
  }
  target:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  value: Expression
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitAssignmentStatement(this)
  }
}
export class AssignmentExpression extends Expression {
  constructor(props: Props<AssignmentExpression>) {
    super(props)
    this.target = props.target
    this.value = props.value
  }
  target:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  value: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitAssignmentExpression(this)
  }
}
export enum EqualityComparison {
  eq = '==',
  ne = '!=',
}
export enum NumericComparison {
  eq = '==',
  ne = '!=',
  lt = '<',
  lte = '<=',
  gt = '>',
  gte = '>=',
}
export class NumericComparisonExpression extends Expression {
  constructor(props: Props<NumericComparisonExpression>) {
    super(props)
    this.wtype = props.wtype
    this.lhs = props.lhs
    this.operator = props.operator
    this.rhs = props.rhs
  }
  lhs: Expression
  operator: NumericComparison
  rhs: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitNumericComparisonExpression(this)
  }
}
export class BytesComparisonExpression extends Expression {
  constructor(props: Props<BytesComparisonExpression>) {
    super(props)
    this.wtype = props.wtype
    this.lhs = props.lhs
    this.operator = props.operator
    this.rhs = props.rhs
  }
  lhs: Expression
  operator: EqualityComparison
  rhs: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBytesComparisonExpression(this)
  }
}
export class InstanceSubroutineTarget {
  constructor(props: Props<InstanceSubroutineTarget>) {
    this.name = props.name
  }
  name: string
}
export class BaseClassSubroutineTarget {
  constructor(props: Props<BaseClassSubroutineTarget>) {
    this.baseClass = props.baseClass
    this.name = props.name
  }
  baseClass: ContractReference
  name: string
}
export class FreeSubroutineTarget {
  constructor(props: Props<FreeSubroutineTarget>) {
    this.moduleName = props.moduleName
    this.name = props.name
  }
  moduleName: string
  name: string
}
export class CallArg {
  constructor(props: Props<CallArg>) {
    this.name = props.name
    this.value = props.value
  }
  name?: string | undefined
  value: Expression
}
export class SubroutineCallExpression extends Expression {
  constructor(props: Props<SubroutineCallExpression>) {
    super(props)
    this.target = props.target
    this.args = props.args
  }
  target: FreeSubroutineTarget | InstanceSubroutineTarget | BaseClassSubroutineTarget
  args: Array<CallArg>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitSubroutineCallExpression(this)
  }
}
export enum UInt64BinaryOperator {
  add = '+',
  sub = '-',
  mult = '*',
  floorDiv = '//',
  mod = '%',
  pow = '**',
  lshift = '<<',
  rshift = '>>',
  bitOr = '|',
  bitXor = '^',
  bitAnd = '&',
}
export enum BigUIntBinaryOperator {
  add = '+',
  sub = '-',
  mult = '*',
  floorDiv = '//',
  mod = '%',
  bitOr = '|',
  bitXor = '^',
  bitAnd = '&',
}
export enum BytesBinaryOperator {
  add = '+',
  bitOr = '|',
  bitXor = '^',
  bitAnd = '&',
}
export enum BytesUnaryOperator {
  bitInvert = '~',
}
export enum UInt64UnaryOperator {
  bitInvert = '~',
}
export enum UInt64PostfixUnaryOperator {
  increment = '++',
  decrement = '--',
}
export class UInt64UnaryOperation extends Expression {
  constructor(props: Props<UInt64UnaryOperation>) {
    super(props)
    this.op = props.op
    this.expr = props.expr
    this.wtype = props.wtype
  }
  op: UInt64UnaryOperator
  expr: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitUInt64UnaryOperation(this)
  }
}
export class UInt64PostfixUnaryOperation extends Expression {
  constructor(props: Props<UInt64PostfixUnaryOperation>) {
    super(props)
    this.op = props.op
    this.target = props.target
    this.wtype = props.wtype
  }
  op: UInt64PostfixUnaryOperator
  target:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitUInt64PostfixUnaryOperation(this)
  }
}
export enum BigUIntPostfixUnaryOperator {
  increment = '++',
  decrement = '--',
}
export class BigUIntPostfixUnaryOperation extends Expression {
  constructor(props: Props<BigUIntPostfixUnaryOperation>) {
    super(props)
    this.op = props.op
    this.target = props.target
    this.wtype = props.wtype
  }
  op: BigUIntPostfixUnaryOperator
  target: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBigUIntPostfixUnaryOperation(this)
  }
}
export class BytesUnaryOperation extends Expression {
  constructor(props: Props<BytesUnaryOperation>) {
    super(props)
    this.op = props.op
    this.expr = props.expr
    this.wtype = props.wtype
  }
  op: BytesUnaryOperator
  expr: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBytesUnaryOperation(this)
  }
}
export class UInt64BinaryOperation extends Expression {
  constructor(props: Props<UInt64BinaryOperation>) {
    super(props)
    this.left = props.left
    this.op = props.op
    this.right = props.right
    this.wtype = props.wtype
  }
  left: Expression
  op: UInt64BinaryOperator
  right: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitUInt64BinaryOperation(this)
  }
}
export class BigUIntBinaryOperation extends Expression {
  constructor(props: Props<BigUIntBinaryOperation>) {
    super(props)
    this.left = props.left
    this.op = props.op
    this.right = props.right
    this.wtype = props.wtype
  }
  left: Expression
  op: BigUIntBinaryOperator
  right: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBigUIntBinaryOperation(this)
  }
}
export class BytesBinaryOperation extends Expression {
  constructor(props: Props<BytesBinaryOperation>) {
    super(props)
    this.left = props.left
    this.op = props.op
    this.right = props.right
    this.wtype = props.wtype
  }
  left: Expression
  op: BytesBinaryOperator
  right: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBytesBinaryOperation(this)
  }
}
export enum BinaryBooleanOperator {
  and = 'and',
  or = 'or',
}
export class BooleanBinaryOperation extends Expression {
  constructor(props: Props<BooleanBinaryOperation>) {
    super(props)
    this.left = props.left
    this.op = props.op
    this.right = props.right
    this.wtype = props.wtype
  }
  left: Expression
  op: BinaryBooleanOperator
  right: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBooleanBinaryOperation(this)
  }
}
export class Not extends Expression {
  constructor(props: Props<Not>) {
    super(props)
    this.expr = props.expr
    this.wtype = props.wtype
  }
  expr: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitNot(this)
  }
}
export class Contains extends Expression {
  constructor(props: Props<Contains>) {
    super(props)
    this.item = props.item
    this.sequence = props.sequence
    this.wtype = props.wtype
  }
  item: Expression
  sequence: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitContains(this)
  }
}
export class UInt64AugmentedAssignment extends Statement {
  constructor(props: Props<UInt64AugmentedAssignment>) {
    super(props)
    this.target = props.target
    this.op = props.op
    this.value = props.value
  }
  target:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  op: UInt64BinaryOperator
  value: Expression
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitUInt64AugmentedAssignment(this)
  }
}
export class BigUIntAugmentedAssignment extends Statement {
  constructor(props: Props<BigUIntAugmentedAssignment>) {
    super(props)
    this.target = props.target
    this.op = props.op
    this.value = props.value
  }
  target:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  op: BigUIntBinaryOperator
  value: Expression
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitBigUIntAugmentedAssignment(this)
  }
}
export class BytesAugmentedAssignment extends Statement {
  constructor(props: Props<BytesAugmentedAssignment>) {
    super(props)
    this.target = props.target
    this.op = props.op
    this.value = props.value
  }
  target:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  op: BytesBinaryOperator
  value: Expression
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitBytesAugmentedAssignment(this)
  }
}
export class OpUp extends Node {
  constructor(props: Props<OpUp>) {
    super(props)
    this.n = props.n
  }
  n: Expression
}
export class Enumeration extends Expression {
  constructor(props: Props<Enumeration>) {
    super(props)
    this.expr = props.expr
  }
  expr: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitEnumeration(this)
  }
}
export class Reversed extends Expression {
  constructor(props: Props<Reversed>) {
    super(props)
    this.expr = props.expr
  }
  expr: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitReversed(this)
  }
}
export class ForInLoop extends Statement {
  constructor(props: Props<ForInLoop>) {
    super(props)
    this.sequence = props.sequence
    this.items = props.items
    this.loopBody = props.loopBody
  }
  sequence: Expression
  items:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  loopBody: Block
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitForInLoop(this)
  }
}
export class StateGet extends Expression {
  constructor(props: Props<StateGet>) {
    super(props)
    this.field = props.field
    this.default = props.default
    this.wtype = props.wtype
  }
  field: AppStateExpression | AppAccountStateExpression | BoxValueExpression
  default: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitStateGet(this)
  }
}
export class StateGetEx extends Expression {
  constructor(props: Props<StateGetEx>) {
    super(props)
    this.field = props.field
    this.wtype = props.wtype
  }
  field: AppStateExpression | AppAccountStateExpression | BoxValueExpression
  declare wtype: wtypes.WTuple
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitStateGetEx(this)
  }
}
export class StateExists extends Expression {
  constructor(props: Props<StateExists>) {
    super(props)
    this.field = props.field
    this.wtype = props.wtype
  }
  field: AppStateExpression | AppAccountStateExpression | BoxValueExpression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitStateExists(this)
  }
}
export class StateDelete extends Expression {
  constructor(props: Props<StateDelete>) {
    super(props)
    this.field = props.field
    this.wtype = props.wtype
  }
  field: AppStateExpression | AppAccountStateExpression | BoxValueExpression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitStateDelete(this)
  }
}
export class NewStruct extends Expression {
  constructor(props: Props<NewStruct>) {
    super(props)
    this.wtype = props.wtype
    this.values = props.values
  }
  declare wtype: wtypes.WStructType | wtypes.ARC4Struct
  values: Map<string, Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitNewStruct(this)
  }
}
export abstract class ModuleStatement extends Node {
  protected constructor(props: Props<ModuleStatement>) {
    super(props)
    this.name = props.name
  }
  name: string
  abstract accept<T>(visitor: ModuleStatementVisitor<T>): T
}
export class ConstantDeclaration extends ModuleStatement {
  constructor(props: Props<ConstantDeclaration>) {
    super(props)
    this.value = props.value
  }
  value: bigint | string | Uint8Array | boolean
  accept<T>(visitor: ModuleStatementVisitor<T>): T {
    return visitor.visitConstantDeclaration(this)
  }
}
export class SubroutineArgument extends Node {
  constructor(props: Props<SubroutineArgument>) {
    super(props)
    this.name = props.name
    this.wtype = props.wtype
  }
  name: string
  wtype: wtypes.WType
}
export abstract class _Function extends ModuleStatement {
  protected constructor(props: Props<_Function>) {
    super(props)
    this.moduleName = props.moduleName
    this.args = props.args
    this.returnType = props.returnType
    this.body = props.body
    this.docstring = props.docstring
  }
  moduleName: string
  args: Array<SubroutineArgument>
  returnType: wtypes.WType
  body: Block
  docstring?: string | undefined
  abstract accept<T>(visitor: ModuleStatementVisitor<T>): T
}
export class Subroutine extends _Function {
  constructor(props: Props<Subroutine>) {
    super(props)
  }
  accept<T>(visitor: ModuleStatementVisitor<T>): T {
    return visitor.visitSubroutine(this)
  }
}
export class ContractMethod extends _Function {
  constructor(props: Props<ContractMethod>) {
    super(props)
    this.className = props.className
    this.arc4MethodConfig = props.arc4MethodConfig
  }
  className: string
  arc4MethodConfig?: ARC4BareMethodConfig | ARC4ABIMethodConfig | undefined
  accept<T>(visitor: ModuleStatementVisitor<T>): T {
    return visitor.visitContractMethod(this)
  }
}
export enum AppStorageKind {
  appGlobal,
  accountLocal,
  box,
}
export class AppStorageDefinition extends Node {
  constructor(props: Props<AppStorageDefinition>) {
    super(props)
    this.memberName = props.memberName
    this.kind = props.kind
    this.storageWtype = props.storageWtype
    this.keyWtype = props.keyWtype
    this.key = props.key
    this.description = props.description
  }
  memberName: string
  kind: AppStorageKind
  storageWtype: wtypes.WType
  keyWtype?: wtypes.WType | undefined
  key: BytesConstant
  description?: string | undefined
}
export class LogicSignature extends ModuleStatement {
  constructor(props: Props<LogicSignature>) {
    super(props)
    this.moduleName = props.moduleName
    this.program = props.program
  }
  moduleName: string
  program: Subroutine
  accept<T>(visitor: ModuleStatementVisitor<T>): T {
    return visitor.visitLogicSignature(this)
  }
}
export class CompiledContract extends Expression {
  constructor(props: Props<CompiledContract>) {
    super(props)
    this.contract = props.contract
    this.allocationOverrides = props.allocationOverrides
    this.prefix = props.prefix
    this.templateVariables = props.templateVariables
  }
  contract: ContractReference
  allocationOverrides: Map<TxnField, Expression>
  prefix?: string | undefined
  templateVariables: Map<string, Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitCompiledContract(this)
  }
}
export class CompiledLogicSig extends Expression {
  constructor(props: Props<CompiledLogicSig>) {
    super(props)
    this.logicSig = props.logicSig
    this.prefix = props.prefix
    this.templateVariables = props.templateVariables
  }
  logicSig: LogicSigReference
  prefix?: string | undefined
  templateVariables: Map<string, Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitCompiledLogicSig(this)
  }
}
export class StateTotals {
  constructor(props: Props<StateTotals>) {
    this.globalUints = props.globalUints
    this.localUints = props.localUints
    this.globalBytes = props.globalBytes
    this.localBytes = props.localBytes
  }
  globalUints?: bigint | undefined
  localUints?: bigint | undefined
  globalBytes?: bigint | undefined
  localBytes?: bigint | undefined
}
export class ContractFragment extends ModuleStatement {
  constructor(props: Props<ContractFragment>) {
    super(props)
    this.moduleName = props.moduleName
    this.nameOverride = props.nameOverride
    this.isAbstract = props.isAbstract
    this.isArc4 = props.isArc4
    this.bases = props.bases
    this.init = props.init
    this.approvalProgram = props.approvalProgram
    this.clearProgram = props.clearProgram
    this.subroutines = props.subroutines
    this.appState = props.appState
    this.reservedScratchSpace = props.reservedScratchSpace
    this.stateTotals = props.stateTotals
    this.docstring = props.docstring
    this.methods = props.methods
  }
  moduleName: string
  nameOverride?: string | undefined
  isAbstract: boolean
  isArc4: boolean
  bases: Array<ContractReference>
  init?: ContractMethod | undefined
  approvalProgram?: ContractMethod | undefined
  clearProgram?: ContractMethod | undefined
  subroutines: Array<ContractMethod>
  appState: Map<string, AppStorageDefinition>
  reservedScratchSpace: Set<bigint>
  stateTotals?: StateTotals | undefined
  docstring?: string | undefined
  methods: Map<string, ContractMethod>
  accept<T>(visitor: ModuleStatementVisitor<T>): T {
    return visitor.visitContractFragment(this)
  }
}
export class StructureField extends Node {
  constructor(props: Props<StructureField>) {
    super(props)
    this.name = props.name
    this.wtype = props.wtype
  }
  name: string
  wtype: wtypes.WType
}
export class StructureDefinition extends ModuleStatement {
  constructor(props: Props<StructureDefinition>) {
    super(props)
    this.fields = props.fields
    this.wtype = props.wtype
    this.docstring = props.docstring
  }
  fields: Array<StructureField>
  wtype: wtypes.WType
  docstring?: string | undefined
  accept<T>(visitor: ModuleStatementVisitor<T>): T {
    return visitor.visitStructureDefinition(this)
  }
}
export class Module {
  constructor(props: Props<Module>) {
    this.name = props.name
    this.sourceFilePath = props.sourceFilePath
    this.body = props.body
  }
  name: string
  sourceFilePath: string
  body: Array<ModuleStatement>
}
export type LValue = VarExpression | FieldExpression | IndexExpression | TupleExpression | AppStateExpression | AppAccountStateExpression
export type Constant = IntegerConstant | BoolConstant | BytesConstant | StringConstant
export const concreteNodes = {
  expressionStatement: ExpressionStatement,
  block: Block,
  goto: Goto,
  ifElse: IfElse,
  switch: Switch,
  whileLoop: WhileLoop,
  loopExit: LoopExit,
  loopContinue: LoopContinue,
  returnStatement: ReturnStatement,
  integerConstant: IntegerConstant,
  decimalConstant: DecimalConstant,
  boolConstant: BoolConstant,
  bytesConstant: BytesConstant,
  stringConstant: StringConstant,
  templateVar: TemplateVar,
  methodConstant: MethodConstant,
  addressConstant: AddressConstant,
  aRC4Encode: ARC4Encode,
  copy: Copy,
  arrayConcat: ArrayConcat,
  arrayPop: ArrayPop,
  arrayExtend: ArrayExtend,
  aRC4Decode: ARC4Decode,
  intrinsicCall: IntrinsicCall,
  createInnerTransaction: CreateInnerTransaction,
  updateInnerTransaction: UpdateInnerTransaction,
  checkedMaybe: CheckedMaybe,
  tupleExpression: TupleExpression,
  tupleItemExpression: TupleItemExpression,
  varExpression: VarExpression,
  innerTransactionField: InnerTransactionField,
  submitInnerTransaction: SubmitInnerTransaction,
  fieldExpression: FieldExpression,
  indexExpression: IndexExpression,
  sliceExpression: SliceExpression,
  intersectionSliceExpression: IntersectionSliceExpression,
  appStateExpression: AppStateExpression,
  appAccountStateExpression: AppAccountStateExpression,
  boxValueExpression: BoxValueExpression,
  singleEvaluation: SingleEvaluation,
  reinterpretCast: ReinterpretCast,
  newArray: NewArray,
  conditionalExpression: ConditionalExpression,
  assignmentStatement: AssignmentStatement,
  assignmentExpression: AssignmentExpression,
  numericComparisonExpression: NumericComparisonExpression,
  bytesComparisonExpression: BytesComparisonExpression,
  instanceSubroutineTarget: InstanceSubroutineTarget,
  baseClassSubroutineTarget: BaseClassSubroutineTarget,
  freeSubroutineTarget: FreeSubroutineTarget,
  callArg: CallArg,
  subroutineCallExpression: SubroutineCallExpression,
  uInt64UnaryOperation: UInt64UnaryOperation,
  uInt64PostfixUnaryOperation: UInt64PostfixUnaryOperation,
  bigUIntPostfixUnaryOperation: BigUIntPostfixUnaryOperation,
  bytesUnaryOperation: BytesUnaryOperation,
  uInt64BinaryOperation: UInt64BinaryOperation,
  bigUIntBinaryOperation: BigUIntBinaryOperation,
  bytesBinaryOperation: BytesBinaryOperation,
  booleanBinaryOperation: BooleanBinaryOperation,
  not: Not,
  contains: Contains,
  uInt64AugmentedAssignment: UInt64AugmentedAssignment,
  bigUIntAugmentedAssignment: BigUIntAugmentedAssignment,
  bytesAugmentedAssignment: BytesAugmentedAssignment,
  opUp: OpUp,
  enumeration: Enumeration,
  reversed: Reversed,
  forInLoop: ForInLoop,
  stateGet: StateGet,
  stateGetEx: StateGetEx,
  stateExists: StateExists,
  stateDelete: StateDelete,
  newStruct: NewStruct,
  constantDeclaration: ConstantDeclaration,
  subroutineArgument: SubroutineArgument,
  subroutine: Subroutine,
  contractMethod: ContractMethod,
  appStorageDefinition: AppStorageDefinition,
  logicSignature: LogicSignature,
  compiledContract: CompiledContract,
  compiledLogicSig: CompiledLogicSig,
  stateTotals: StateTotals,
  contractFragment: ContractFragment,
  structureField: StructureField,
  structureDefinition: StructureDefinition,
  module: Module,
  uInt64Constant: IntegerConstant,
  bigUIntConstant: IntegerConstant,
} as const
export interface ExpressionVisitor<T> {
  visitIntegerConstant(expression: IntegerConstant): T
  visitDecimalConstant(expression: DecimalConstant): T
  visitBoolConstant(expression: BoolConstant): T
  visitBytesConstant(expression: BytesConstant): T
  visitStringConstant(expression: StringConstant): T
  visitTemplateVar(expression: TemplateVar): T
  visitMethodConstant(expression: MethodConstant): T
  visitAddressConstant(expression: AddressConstant): T
  visitARC4Encode(expression: ARC4Encode): T
  visitCopy(expression: Copy): T
  visitArrayConcat(expression: ArrayConcat): T
  visitArrayPop(expression: ArrayPop): T
  visitArrayExtend(expression: ArrayExtend): T
  visitARC4Decode(expression: ARC4Decode): T
  visitIntrinsicCall(expression: IntrinsicCall): T
  visitCreateInnerTransaction(expression: CreateInnerTransaction): T
  visitUpdateInnerTransaction(expression: UpdateInnerTransaction): T
  visitCheckedMaybe(expression: CheckedMaybe): T
  visitTupleExpression(expression: TupleExpression): T
  visitTupleItemExpression(expression: TupleItemExpression): T
  visitVarExpression(expression: VarExpression): T
  visitInnerTransactionField(expression: InnerTransactionField): T
  visitSubmitInnerTransaction(expression: SubmitInnerTransaction): T
  visitFieldExpression(expression: FieldExpression): T
  visitIndexExpression(expression: IndexExpression): T
  visitSliceExpression(expression: SliceExpression): T
  visitIntersectionSliceExpression(expression: IntersectionSliceExpression): T
  visitAppStateExpression(expression: AppStateExpression): T
  visitAppAccountStateExpression(expression: AppAccountStateExpression): T
  visitBoxValueExpression(expression: BoxValueExpression): T
  visitSingleEvaluation(expression: SingleEvaluation): T
  visitReinterpretCast(expression: ReinterpretCast): T
  visitNewArray(expression: NewArray): T
  visitConditionalExpression(expression: ConditionalExpression): T
  visitAssignmentExpression(expression: AssignmentExpression): T
  visitNumericComparisonExpression(expression: NumericComparisonExpression): T
  visitBytesComparisonExpression(expression: BytesComparisonExpression): T
  visitSubroutineCallExpression(expression: SubroutineCallExpression): T
  visitUInt64UnaryOperation(expression: UInt64UnaryOperation): T
  visitUInt64PostfixUnaryOperation(expression: UInt64PostfixUnaryOperation): T
  visitBigUIntPostfixUnaryOperation(expression: BigUIntPostfixUnaryOperation): T
  visitBytesUnaryOperation(expression: BytesUnaryOperation): T
  visitUInt64BinaryOperation(expression: UInt64BinaryOperation): T
  visitBigUIntBinaryOperation(expression: BigUIntBinaryOperation): T
  visitBytesBinaryOperation(expression: BytesBinaryOperation): T
  visitBooleanBinaryOperation(expression: BooleanBinaryOperation): T
  visitNot(expression: Not): T
  visitContains(expression: Contains): T
  visitEnumeration(expression: Enumeration): T
  visitReversed(expression: Reversed): T
  visitStateGet(expression: StateGet): T
  visitStateGetEx(expression: StateGetEx): T
  visitStateExists(expression: StateExists): T
  visitStateDelete(expression: StateDelete): T
  visitNewStruct(expression: NewStruct): T
  visitCompiledContract(expression: CompiledContract): T
  visitCompiledLogicSig(expression: CompiledLogicSig): T
}
export interface StatementVisitor<T> {
  visitExpressionStatement(statement: ExpressionStatement): T
  visitBlock(statement: Block): T
  visitGoto(statement: Goto): T
  visitIfElse(statement: IfElse): T
  visitSwitch(statement: Switch): T
  visitWhileLoop(statement: WhileLoop): T
  visitLoopExit(statement: LoopExit): T
  visitLoopContinue(statement: LoopContinue): T
  visitReturnStatement(statement: ReturnStatement): T
  visitAssignmentStatement(statement: AssignmentStatement): T
  visitUInt64AugmentedAssignment(statement: UInt64AugmentedAssignment): T
  visitBigUIntAugmentedAssignment(statement: BigUIntAugmentedAssignment): T
  visitBytesAugmentedAssignment(statement: BytesAugmentedAssignment): T
  visitForInLoop(statement: ForInLoop): T
}
export interface ModuleStatementVisitor<T> {
  visitConstantDeclaration(moduleStatement: ConstantDeclaration): T
  visitSubroutine(moduleStatement: Subroutine): T
  visitContractMethod(moduleStatement: ContractMethod): T
  visitLogicSignature(moduleStatement: LogicSignature): T
  visitContractFragment(moduleStatement: ContractFragment): T
  visitStructureDefinition(moduleStatement: StructureDefinition): T
}
