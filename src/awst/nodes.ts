/* AUTOGENERATED FILE - DO NOT EDIT (see puya/scripts/generate_ts_nodes.py) */
import type * as wtypes from './wtypes'
import type { SourceLocation } from './source-location'
import type { ARC4BareMethodConfig, ARC4ABIMethodConfig, ContractReference, LogicSigReference } from './models'
import type { Props } from '../typescript-helpers'
import { classes } from 'polytype'
import type { TxnField } from './txn-fields'
export class SubroutineID {
  constructor(props: Props<SubroutineID>) {
    this.target = props.target
  }
  target: string
}
export abstract class Node {
  constructor(props: Props<Node>) {
    this.sourceLocation = props.sourceLocation
  }
  sourceLocation: SourceLocation
}
export abstract class Statement extends Node {
  constructor(props: Props<Statement>) {
    super(props)
  }
  abstract accept<T>(visitor: StatementVisitor<T>): T
}
export abstract class Expression extends Node {
  constructor(props: Props<Expression>) {
    super(props)
    this.wtype = props.wtype
  }
  wtype: wtypes.WType
  abstract accept<T>(visitor: ExpressionVisitor<T>): T
}
export class ExpressionStatement extends Statement {
  constructor(props: Props<ExpressionStatement>) {
    super(props)
    this.expr = props.expr
    this.sourceLocation = props.sourceLocation
  }
  expr: Expression
  sourceLocation: SourceLocation
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitExpressionStatement(this)
  }
}
export class Block extends Statement {
  constructor(props: Props<Block>) {
    super(props)
    this.body = props.body
    this.label = props.label
    this.comment = props.comment
  }
  body: Array<Statement>
  label: string | null
  comment: string | null
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitBlock(this)
  }
}
export class Goto extends Statement {
  constructor(props: Props<Goto>) {
    super(props)
    this.target = props.target
  }
  target: string
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitGoto(this)
  }
}
export class IfElse extends Statement {
  constructor(props: Props<IfElse>) {
    super(props)
    this.condition = props.condition
    this.ifBranch = props.ifBranch
    this.elseBranch = props.elseBranch
  }
  condition: Expression
  ifBranch: Block
  elseBranch: Block | null
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitIfElse(this)
  }
}
export class Switch extends Statement {
  constructor(props: Props<Switch>) {
    super(props)
    this.value = props.value
    this.cases = props.cases
    this.defaultCase = props.defaultCase
  }
  value: Expression
  cases: Map<Expression, Block>
  defaultCase: Block | null
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitSwitch(this)
  }
}
export class WhileLoop extends Statement {
  constructor(props: Props<WhileLoop>) {
    super(props)
    this.condition = props.condition
    this.loopBody = props.loopBody
  }
  condition: Expression
  loopBody: Block
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitWhileLoop(this)
  }
}
export class LoopExit extends Statement {
  constructor(props: Props<LoopExit>) {
    super(props)
  }
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitLoopExit(this)
  }
}
export class LoopContinue extends Statement {
  constructor(props: Props<LoopContinue>) {
    super(props)
  }
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitLoopContinue(this)
  }
}
export class ReturnStatement extends Statement {
  constructor(props: Props<ReturnStatement>) {
    super(props)
    this.value = props.value
  }
  value: Expression | null
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitReturnStatement(this)
  }
}
export class IntegerConstant extends Expression {
  constructor(props: Props<IntegerConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
    this.tealAlias = props.tealAlias
  }
  value: bigint
  tealAlias: string | null
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitIntegerConstant(this)
  }
}
export class DecimalConstant extends Expression {
  constructor(props: Props<DecimalConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
  }
  declare wtype: wtypes.ARC4UFixedNxM
  value: number
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitDecimalConstant(this)
  }
}
export class BoolConstant extends Expression {
  constructor(props: Props<BoolConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
  }
  value: boolean
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBoolConstant(this)
  }
}
export enum BytesEncoding {
  unknown = 'unknown',
  base16 = 'base16',
  base32 = 'base32',
  base64 = 'base64',
  utf8 = 'utf8',
}
export class BytesConstant extends Expression {
  constructor(props: Props<BytesConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
    this.encoding = props.encoding
  }
  value: Uint8Array
  encoding: BytesEncoding
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBytesConstant(this)
  }
}
export class StringConstant extends Expression {
  constructor(props: Props<StringConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
  }
  value: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitStringConstant(this)
  }
}
export class VoidConstant extends Expression {
  constructor(props: Props<VoidConstant>) {
    super(props)
    this.wtype = props.wtype
  }
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitVoidConstant(this)
  }
}
export class TemplateVar extends Expression {
  constructor(props: Props<TemplateVar>) {
    super(props)
    this.wtype = props.wtype
    this.name = props.name
  }
  name: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitTemplateVar(this)
  }
}
export class MethodConstant extends Expression {
  constructor(props: Props<MethodConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
  }
  value: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitMethodConstant(this)
  }
}
export class AddressConstant extends Expression {
  constructor(props: Props<AddressConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
  }
  value: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitAddressConstant(this)
  }
}
export class ARC4Encode extends Expression {
  constructor(props: Props<ARC4Encode>) {
    super(props)
    this.value = props.value
    this.wtype = props.wtype
  }
  value: Expression
  declare wtype: wtypes.ARC4Type
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitARC4Encode(this)
  }
}
export class Copy extends Expression {
  constructor(props: Props<Copy>) {
    super(props)
    this.value = props.value
    this.wtype = props.wtype
  }
  value: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitCopy(this)
  }
}
export class ArrayConcat extends Expression {
  constructor(props: Props<ArrayConcat>) {
    super(props)
    this.left = props.left
    this.right = props.right
  }
  left: Expression
  right: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitArrayConcat(this)
  }
}
export class ArrayPop extends Expression {
  constructor(props: Props<ArrayPop>) {
    super(props)
    this.base = props.base
  }
  base: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitArrayPop(this)
  }
}
export class ArrayExtend extends Expression {
  constructor(props: Props<ArrayExtend>) {
    super(props)
    this.base = props.base
    this.other = props.other
  }
  base: Expression
  other: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitArrayExtend(this)
  }
}
export class ARC4Decode extends Expression {
  constructor(props: Props<ARC4Decode>) {
    super(props)
    this.value = props.value
  }
  value: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitARC4Decode(this)
  }
}
export class IntrinsicCall extends Expression {
  constructor(props: Props<IntrinsicCall>) {
    super(props)
    this.opCode = props.opCode
    this.immediates = props.immediates
    this.stackArgs = props.stackArgs
    this.comment = props.comment
  }
  opCode: string
  immediates: Array<string | bigint>
  stackArgs: Array<Expression>
  comment: string | null
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitIntrinsicCall(this)
  }
}
export class CreateInnerTransaction extends Expression {
  constructor(props: Props<CreateInnerTransaction>) {
    super(props)
    this.wtype = props.wtype
    this.fields = props.fields
  }
  declare wtype: wtypes.WInnerTransactionFields
  fields: Map<TxnField, Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitCreateInnerTransaction(this)
  }
}
export class UpdateInnerTransaction extends Expression {
  constructor(props: Props<UpdateInnerTransaction>) {
    super(props)
    this.itxn = props.itxn
    this.fields = props.fields
    this.wtype = props.wtype
  }
  itxn: Expression
  fields: Map<TxnField, Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitUpdateInnerTransaction(this)
  }
}
export class GroupTransactionReference extends Expression {
  constructor(props: Props<GroupTransactionReference>) {
    super(props)
    this.index = props.index
    this.wtype = props.wtype
  }
  index: Expression
  declare wtype: wtypes.WGroupTransaction
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitGroupTransactionReference(this)
  }
}
export class CheckedMaybe extends Expression {
  constructor(props: Props<CheckedMaybe>) {
    super(props)
    this.expr = props.expr
    this.comment = props.comment
    this.wtype = props.wtype
    this.sourceLocation = props.sourceLocation
  }
  expr: Expression
  comment: string
  sourceLocation: SourceLocation
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitCheckedMaybe(this)
  }
}
export class TupleExpression extends Expression {
  constructor(props: Props<TupleExpression>) {
    super(props)
    this.items = props.items
    this.wtype = props.wtype
  }
  items: Array<Expression>
  declare wtype: wtypes.WTuple
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitTupleExpression(this)
  }
}
export class TupleItemExpression extends Expression {
  constructor(props: Props<TupleItemExpression>) {
    super(props)
    this.base = props.base
    this.index = props.index
    this.wtype = props.wtype
  }
  base: Expression
  index: bigint
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitTupleItemExpression(this)
  }
}
export class VarExpression extends Expression {
  constructor(props: Props<VarExpression>) {
    super(props)
    this.name = props.name
  }
  name: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitVarExpression(this)
  }
}
export class InnerTransactionField extends Expression {
  constructor(props: Props<InnerTransactionField>) {
    super(props)
    this.itxn = props.itxn
    this.field = props.field
    this.arrayIndex = props.arrayIndex
  }
  itxn: Expression
  field: TxnField
  arrayIndex: Expression | null
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitInnerTransactionField(this)
  }
}
export class SubmitInnerTransaction extends Expression {
  constructor(props: Props<SubmitInnerTransaction>) {
    super(props)
    this.itxns = props.itxns
    this.wtype = props.wtype
  }
  itxns: Array<Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitSubmitInnerTransaction(this)
  }
}
export class FieldExpression extends Expression {
  constructor(props: Props<FieldExpression>) {
    super(props)
    this.base = props.base
    this.name = props.name
    this.wtype = props.wtype
  }
  base: Expression
  name: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitFieldExpression(this)
  }
}
export class IndexExpression extends Expression {
  constructor(props: Props<IndexExpression>) {
    super(props)
    this.base = props.base
    this.index = props.index
  }
  base: Expression
  index: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitIndexExpression(this)
  }
}
export class SliceExpression extends Expression {
  constructor(props: Props<SliceExpression>) {
    super(props)
    this.base = props.base
    this.beginIndex = props.beginIndex
    this.endIndex = props.endIndex
  }
  base: Expression
  beginIndex: Expression | null
  endIndex: Expression | null
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitSliceExpression(this)
  }
}
export class IntersectionSliceExpression extends Expression {
  constructor(props: Props<IntersectionSliceExpression>) {
    super(props)
    this.base = props.base
    this.beginIndex = props.beginIndex
    this.endIndex = props.endIndex
  }
  base: Expression
  beginIndex: Expression | bigint | null
  endIndex: Expression | bigint | null
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitIntersectionSliceExpression(this)
  }
}
export class AppStateExpression extends Expression {
  constructor(props: Props<AppStateExpression>) {
    super(props)
    this.key = props.key
    this.existsAssertionMessage = props.existsAssertionMessage
  }
  key: Expression
  existsAssertionMessage: string | null
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitAppStateExpression(this)
  }
}
export class AppAccountStateExpression extends Expression {
  constructor(props: Props<AppAccountStateExpression>) {
    super(props)
    this.key = props.key
    this.existsAssertionMessage = props.existsAssertionMessage
    this.account = props.account
  }
  key: Expression
  existsAssertionMessage: string | null
  account: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitAppAccountStateExpression(this)
  }
}
export class BoxValueExpression extends Expression {
  constructor(props: Props<BoxValueExpression>) {
    super(props)
    this.key = props.key
    this.existsAssertionMessage = props.existsAssertionMessage
  }
  key: Expression
  existsAssertionMessage: string | null
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBoxValueExpression(this)
  }
}
export class SingleEvaluation extends Expression {
  constructor(props: Props<SingleEvaluation>) {
    super(props)
    this.source = props.source
    this.id = props.id
    this.wtype = props.wtype
    this.sourceLocation = props.sourceLocation
  }
  source: Expression
  id: bigint
  sourceLocation: SourceLocation
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitSingleEvaluation(this)
  }
}
export class ReinterpretCast extends Expression {
  constructor(props: Props<ReinterpretCast>) {
    super(props)
    this.expr = props.expr
  }
  expr: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitReinterpretCast(this)
  }
}
export class NewArray extends Expression {
  constructor(props: Props<NewArray>) {
    super(props)
    this.wtype = props.wtype
    this.values = props.values
  }
  declare wtype: wtypes.WArray | wtypes.ARC4Array
  values: Array<Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitNewArray(this)
  }
}
export class ConditionalExpression extends Expression {
  constructor(props: Props<ConditionalExpression>) {
    super(props)
    this.condition = props.condition
    this.trueExpr = props.trueExpr
    this.falseExpr = props.falseExpr
    this.wtype = props.wtype
  }
  condition: Expression
  trueExpr: Expression
  falseExpr: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitConditionalExpression(this)
  }
}
export class AssignmentStatement extends Statement {
  constructor(props: Props<AssignmentStatement>) {
    super(props)
    this.target = props.target
    this.value = props.value
  }
  target:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  value: Expression
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitAssignmentStatement(this)
  }
}
export class AssignmentExpression extends Expression {
  constructor(props: Props<AssignmentExpression>) {
    super(props)
    this.target = props.target
    this.value = props.value
    this.wtype = props.wtype
  }
  target:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  value: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitAssignmentExpression(this)
  }
}
export enum EqualityComparison {
  eq = '==',
  ne = '!=',
}
export enum NumericComparison {
  eq = '==',
  ne = '!=',
  lt = '<',
  lte = '<=',
  gt = '>',
  gte = '>=',
}
export class NumericComparisonExpression extends Expression {
  constructor(props: Props<NumericComparisonExpression>) {
    super(props)
    this.wtype = props.wtype
    this.lhs = props.lhs
    this.operator = props.operator
    this.rhs = props.rhs
  }
  lhs: Expression
  operator: NumericComparison
  rhs: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitNumericComparisonExpression(this)
  }
}
export class BytesComparisonExpression extends Expression {
  constructor(props: Props<BytesComparisonExpression>) {
    super(props)
    this.wtype = props.wtype
    this.lhs = props.lhs
    this.operator = props.operator
    this.rhs = props.rhs
  }
  lhs: Expression
  operator: EqualityComparison
  rhs: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBytesComparisonExpression(this)
  }
}
export class InstanceMethodTarget {
  constructor(props: Props<InstanceMethodTarget>) {
    this.memberName = props.memberName
  }
  memberName: string
}
export class InstanceSuperMethodTarget {
  constructor(props: Props<InstanceSuperMethodTarget>) {
    this.memberName = props.memberName
  }
  memberName: string
}
export class ContractMethodTarget {
  constructor(props: Props<ContractMethodTarget>) {
    this.cref = props.cref
    this.memberName = props.memberName
  }
  cref: ContractReference
  memberName: string
}
export class CallArg {
  constructor(props: Props<CallArg>) {
    this.name = props.name
    this.value = props.value
  }
  name: string | null
  value: Expression
}
export class SubroutineCallExpression extends Expression {
  constructor(props: Props<SubroutineCallExpression>) {
    super(props)
    this.target = props.target
    this.args = props.args
  }
  target: SubroutineID | InstanceMethodTarget | InstanceSuperMethodTarget | ContractMethodTarget
  args: Array<CallArg>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitSubroutineCallExpression(this)
  }
}
export class PuyaLibData {
  constructor(props: Props<PuyaLibData>) {
    this.id = props.id
    this.params = props.params
    this.wtype = props.wtype
  }
  id: string
  params: Map<string, wtypes.WType>
  wtype: wtypes.WType
}
export enum PuyaLibFunction {
  ensureBudget = 'ensure_budget',
  isSubstring = 'is_substring',
}
export class PuyaLibCall extends Expression {
  constructor(props: Props<PuyaLibCall>) {
    super(props)
    this.func = props.func
    this.args = props.args
    this.wtype = props.wtype
  }
  func: PuyaLibFunction
  args: Array<CallArg>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitPuyaLibCall(this)
  }
}
export enum UInt64BinaryOperator {
  add = '+',
  sub = '-',
  mult = '*',
  floorDiv = '//',
  mod = '%',
  pow = '**',
  lshift = '<<',
  rshift = '>>',
  bitOr = '|',
  bitXor = '^',
  bitAnd = '&',
}
export enum BigUIntBinaryOperator {
  add = '+',
  sub = '-',
  mult = '*',
  floorDiv = '//',
  mod = '%',
  bitOr = '|',
  bitXor = '^',
  bitAnd = '&',
}
export enum BytesBinaryOperator {
  add = '+',
  bitOr = '|',
  bitXor = '^',
  bitAnd = '&',
}
export enum BytesUnaryOperator {
  bitInvert = '~',
}
export enum UInt64UnaryOperator {
  bitInvert = '~',
}
export enum UInt64PostfixUnaryOperator {
  increment = '++',
  decrement = '--',
}
export class UInt64UnaryOperation extends Expression {
  constructor(props: Props<UInt64UnaryOperation>) {
    super(props)
    this.op = props.op
    this.expr = props.expr
    this.wtype = props.wtype
  }
  op: UInt64UnaryOperator
  expr: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitUInt64UnaryOperation(this)
  }
}
export class UInt64PostfixUnaryOperation extends Expression {
  constructor(props: Props<UInt64PostfixUnaryOperation>) {
    super(props)
    this.op = props.op
    this.target = props.target
    this.wtype = props.wtype
  }
  op: UInt64PostfixUnaryOperator
  target:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitUInt64PostfixUnaryOperation(this)
  }
}
export enum BigUIntPostfixUnaryOperator {
  increment = '++',
  decrement = '--',
}
export class BigUIntPostfixUnaryOperation extends Expression {
  constructor(props: Props<BigUIntPostfixUnaryOperation>) {
    super(props)
    this.op = props.op
    this.target = props.target
    this.wtype = props.wtype
  }
  op: BigUIntPostfixUnaryOperator
  target: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBigUIntPostfixUnaryOperation(this)
  }
}
export class BytesUnaryOperation extends Expression {
  constructor(props: Props<BytesUnaryOperation>) {
    super(props)
    this.op = props.op
    this.expr = props.expr
    this.wtype = props.wtype
  }
  op: BytesUnaryOperator
  expr: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBytesUnaryOperation(this)
  }
}
export class UInt64BinaryOperation extends Expression {
  constructor(props: Props<UInt64BinaryOperation>) {
    super(props)
    this.left = props.left
    this.op = props.op
    this.right = props.right
    this.wtype = props.wtype
  }
  left: Expression
  op: UInt64BinaryOperator
  right: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitUInt64BinaryOperation(this)
  }
}
export class BigUIntBinaryOperation extends Expression {
  constructor(props: Props<BigUIntBinaryOperation>) {
    super(props)
    this.left = props.left
    this.op = props.op
    this.right = props.right
    this.wtype = props.wtype
  }
  left: Expression
  op: BigUIntBinaryOperator
  right: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBigUIntBinaryOperation(this)
  }
}
export class BytesBinaryOperation extends Expression {
  constructor(props: Props<BytesBinaryOperation>) {
    super(props)
    this.left = props.left
    this.op = props.op
    this.right = props.right
    this.wtype = props.wtype
  }
  left: Expression
  op: BytesBinaryOperator
  right: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBytesBinaryOperation(this)
  }
}
export enum BinaryBooleanOperator {
  and = 'and',
  or = 'or',
}
export class BooleanBinaryOperation extends Expression {
  constructor(props: Props<BooleanBinaryOperation>) {
    super(props)
    this.left = props.left
    this.op = props.op
    this.right = props.right
    this.wtype = props.wtype
  }
  left: Expression
  op: BinaryBooleanOperator
  right: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBooleanBinaryOperation(this)
  }
}
export class Not extends Expression {
  constructor(props: Props<Not>) {
    super(props)
    this.expr = props.expr
    this.wtype = props.wtype
  }
  expr: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitNot(this)
  }
}
export class UInt64AugmentedAssignment extends Statement {
  constructor(props: Props<UInt64AugmentedAssignment>) {
    super(props)
    this.target = props.target
    this.op = props.op
    this.value = props.value
  }
  target:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  op: UInt64BinaryOperator
  value: Expression
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitUInt64AugmentedAssignment(this)
  }
}
export class BigUIntAugmentedAssignment extends Statement {
  constructor(props: Props<BigUIntAugmentedAssignment>) {
    super(props)
    this.target = props.target
    this.op = props.op
    this.value = props.value
  }
  target:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  op: BigUIntBinaryOperator
  value: Expression
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitBigUIntAugmentedAssignment(this)
  }
}
export class BytesAugmentedAssignment extends Statement {
  constructor(props: Props<BytesAugmentedAssignment>) {
    super(props)
    this.target = props.target
    this.op = props.op
    this.value = props.value
  }
  target:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  op: BytesBinaryOperator
  value: Expression
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitBytesAugmentedAssignment(this)
  }
}
export class Enumeration extends Expression {
  constructor(props: Props<Enumeration>) {
    super(props)
    this.expr = props.expr
    this.wtype = props.wtype
  }
  expr: Expression
  declare wtype: wtypes.WEnumeration
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitEnumeration(this)
  }
}
export class Reversed extends Expression {
  constructor(props: Props<Reversed>) {
    super(props)
    this.expr = props.expr
    this.wtype = props.wtype
  }
  expr: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitReversed(this)
  }
}
export class ForInLoop extends Statement {
  constructor(props: Props<ForInLoop>) {
    super(props)
    this.sequence = props.sequence
    this.items = props.items
    this.loopBody = props.loopBody
  }
  sequence: Expression
  items:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  loopBody: Block
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitForInLoop(this)
  }
}
export class StateGet extends Expression {
  constructor(props: Props<StateGet>) {
    super(props)
    this.field = props.field
    this.default = props.default
    this.wtype = props.wtype
  }
  field: AppStateExpression | AppAccountStateExpression | BoxValueExpression
  default: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitStateGet(this)
  }
}
export class StateGetEx extends Expression {
  constructor(props: Props<StateGetEx>) {
    super(props)
    this.field = props.field
    this.wtype = props.wtype
  }
  field: AppStateExpression | AppAccountStateExpression | BoxValueExpression
  declare wtype: wtypes.WTuple
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitStateGetEx(this)
  }
}
export class StateExists extends Expression {
  constructor(props: Props<StateExists>) {
    super(props)
    this.field = props.field
    this.wtype = props.wtype
  }
  field: AppStateExpression | AppAccountStateExpression | BoxValueExpression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitStateExists(this)
  }
}
export class StateDelete extends Expression {
  constructor(props: Props<StateDelete>) {
    super(props)
    this.field = props.field
    this.wtype = props.wtype
  }
  field: AppStateExpression | AppAccountStateExpression | BoxValueExpression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitStateDelete(this)
  }
}
export class NewStruct extends Expression {
  constructor(props: Props<NewStruct>) {
    super(props)
    this.wtype = props.wtype
    this.values = props.values
  }
  declare wtype: wtypes.WStructType | wtypes.ARC4Struct
  values: Map<string, Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitNewStruct(this)
  }
}
export abstract class RootNode extends Node {
  constructor(props: Props<RootNode>) {
    super(props)
  }
  abstract accept<T>(visitor: RootNodeVisitor<T>): T
}
export class SubroutineArgument {
  constructor(props: Props<SubroutineArgument>) {
    this.name = props.name
    this.wtype = props.wtype
    this.sourceLocation = props.sourceLocation
  }
  name: string
  wtype: wtypes.WType
  sourceLocation: SourceLocation | null
}
export class MethodDocumentation {
  constructor(props: Props<MethodDocumentation>) {
    this.description = props.description
    this.args = props.args
    this.returns = props.returns
  }
  description: string | null
  args: Map<string, string>
  returns: string | null
}
export abstract class _Function extends Node {
  constructor(props: Props<_Function>) {
    super(props)
    this.args = props.args
    this.returnType = props.returnType
    this.body = props.body
    this.documentation = props.documentation
  }
  args: Array<SubroutineArgument>
  returnType: wtypes.WType
  body: Block
  documentation: MethodDocumentation
}
export class Subroutine extends classes(_Function, RootNode) {
  constructor(props: Props<Subroutine>) {
    super([props], [props])
    this.id = props.id
    this.name = props.name
  }
  id: string
  name: string
  accept<T>(visitor: RootNodeVisitor<T>): T {
    return visitor.visitSubroutine(this)
  }
}
export abstract class ContractMemberNode extends Node {
  constructor(props: Props<ContractMemberNode>) {
    super(props)
  }
  abstract accept<T>(visitor: ContractMemberNodeVisitor<T>): T
}
export class ContractMethod extends classes(_Function, ContractMemberNode) {
  constructor(props: Props<ContractMethod>) {
    super([props], [props])
    this.cref = props.cref
    this.memberName = props.memberName
    this.arc4MethodConfig = props.arc4MethodConfig
    this.synthetic = props.synthetic
    this.inheritable = props.inheritable
  }
  cref: ContractReference
  memberName: string
  arc4MethodConfig: ARC4BareMethodConfig | ARC4ABIMethodConfig | null
  synthetic: boolean
  inheritable: boolean
  accept<T>(visitor: ContractMemberNodeVisitor<T>): T {
    return visitor.visitContractMethod(this)
  }
}
export enum AppStorageKind {
  appGlobal,
  accountLocal,
  box,
}
export class AppStorageDefinition extends ContractMemberNode {
  constructor(props: Props<AppStorageDefinition>) {
    super(props)
    this.memberName = props.memberName
    this.kind = props.kind
    this.storageWtype = props.storageWtype
    this.keyWtype = props.keyWtype
    this.key = props.key
    this.description = props.description
  }
  memberName: string
  kind: AppStorageKind
  storageWtype: wtypes.WType
  keyWtype: wtypes.WType | null
  key: BytesConstant
  description: string | null
  accept<T>(visitor: ContractMemberNodeVisitor<T>): T {
    return visitor.visitAppStorageDefinition(this)
  }
}
export class LogicSignature extends RootNode {
  constructor(props: Props<LogicSignature>) {
    super(props)
    this.id = props.id
    this.shortName = props.shortName
    this.program = props.program
    this.docstring = props.docstring
  }
  id: LogicSigReference
  shortName: string
  program: Subroutine
  docstring: string | null
  accept<T>(visitor: RootNodeVisitor<T>): T {
    return visitor.visitLogicSignature(this)
  }
}
export class CompiledContract extends Expression {
  constructor(props: Props<CompiledContract>) {
    super(props)
    this.contract = props.contract
    this.allocationOverrides = props.allocationOverrides
    this.prefix = props.prefix
    this.templateVariables = props.templateVariables
  }
  contract: ContractReference
  allocationOverrides: Map<TxnField, Expression>
  prefix: string | null
  templateVariables: Map<string, Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitCompiledContract(this)
  }
}
export class CompiledLogicSig extends Expression {
  constructor(props: Props<CompiledLogicSig>) {
    super(props)
    this.logicSig = props.logicSig
    this.prefix = props.prefix
    this.templateVariables = props.templateVariables
  }
  logicSig: LogicSigReference
  prefix: string | null
  templateVariables: Map<string, Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitCompiledLogicSig(this)
  }
}
export class StateTotals {
  constructor(props: Props<StateTotals>) {
    this.globalUints = props.globalUints
    this.localUints = props.localUints
    this.globalBytes = props.globalBytes
    this.localBytes = props.localBytes
  }
  globalUints: bigint | null
  localUints: bigint | null
  globalBytes: bigint | null
  localBytes: bigint | null
}
export class ARC4Router extends Expression {
  constructor(props: Props<ARC4Router>) {
    super(props)
    this.wtype = props.wtype
  }
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitARC4Router(this)
  }
}
export class ContractFragment extends RootNode {
  constructor(props: Props<ContractFragment>) {
    super(props)
    this.id = props.id
    this.name = props.name
    this.bases = props.bases
    this.init = props.init
    this.approvalProgram = props.approvalProgram
    this.clearProgram = props.clearProgram
    this.subroutines = props.subroutines
    this.appState = props.appState
    this.reservedScratchSpace = props.reservedScratchSpace
    this.stateTotals = props.stateTotals
    this.docstring = props.docstring
  }
  id: ContractReference
  name: string
  bases: Array<ContractReference>
  init: ContractMethod | null
  approvalProgram: ContractMethod | null
  clearProgram: ContractMethod | null
  subroutines: Array<ContractMethod>
  appState: Map<string, AppStorageDefinition>
  reservedScratchSpace: Set<bigint>
  stateTotals: StateTotals | null
  docstring: string | null
  accept<T>(visitor: RootNodeVisitor<T>): T {
    return visitor.visitContractFragment(this)
  }
}
export type LValue = VarExpression | FieldExpression | IndexExpression | TupleExpression | AppStateExpression | AppAccountStateExpression
export type Constant = IntegerConstant | BoolConstant | BytesConstant | StringConstant
export type AWST = ContractFragment | LogicSignature | Subroutine
export const concreteNodes = {
  subroutineID: SubroutineID,
  expressionStatement: ExpressionStatement,
  block: Block,
  goto: Goto,
  ifElse: IfElse,
  switch: Switch,
  whileLoop: WhileLoop,
  loopExit: LoopExit,
  loopContinue: LoopContinue,
  returnStatement: ReturnStatement,
  integerConstant: IntegerConstant,
  decimalConstant: DecimalConstant,
  boolConstant: BoolConstant,
  bytesConstant: BytesConstant,
  stringConstant: StringConstant,
  voidConstant: VoidConstant,
  templateVar: TemplateVar,
  methodConstant: MethodConstant,
  addressConstant: AddressConstant,
  aRC4Encode: ARC4Encode,
  copy: Copy,
  arrayConcat: ArrayConcat,
  arrayPop: ArrayPop,
  arrayExtend: ArrayExtend,
  aRC4Decode: ARC4Decode,
  intrinsicCall: IntrinsicCall,
  createInnerTransaction: CreateInnerTransaction,
  updateInnerTransaction: UpdateInnerTransaction,
  groupTransactionReference: GroupTransactionReference,
  checkedMaybe: CheckedMaybe,
  tupleExpression: TupleExpression,
  tupleItemExpression: TupleItemExpression,
  varExpression: VarExpression,
  innerTransactionField: InnerTransactionField,
  submitInnerTransaction: SubmitInnerTransaction,
  fieldExpression: FieldExpression,
  indexExpression: IndexExpression,
  sliceExpression: SliceExpression,
  intersectionSliceExpression: IntersectionSliceExpression,
  appStateExpression: AppStateExpression,
  appAccountStateExpression: AppAccountStateExpression,
  boxValueExpression: BoxValueExpression,
  singleEvaluation: SingleEvaluation,
  reinterpretCast: ReinterpretCast,
  newArray: NewArray,
  conditionalExpression: ConditionalExpression,
  assignmentStatement: AssignmentStatement,
  assignmentExpression: AssignmentExpression,
  numericComparisonExpression: NumericComparisonExpression,
  bytesComparisonExpression: BytesComparisonExpression,
  instanceMethodTarget: InstanceMethodTarget,
  instanceSuperMethodTarget: InstanceSuperMethodTarget,
  contractMethodTarget: ContractMethodTarget,
  callArg: CallArg,
  subroutineCallExpression: SubroutineCallExpression,
  puyaLibData: PuyaLibData,
  puyaLibCall: PuyaLibCall,
  uInt64UnaryOperation: UInt64UnaryOperation,
  uInt64PostfixUnaryOperation: UInt64PostfixUnaryOperation,
  bigUIntPostfixUnaryOperation: BigUIntPostfixUnaryOperation,
  bytesUnaryOperation: BytesUnaryOperation,
  uInt64BinaryOperation: UInt64BinaryOperation,
  bigUIntBinaryOperation: BigUIntBinaryOperation,
  bytesBinaryOperation: BytesBinaryOperation,
  booleanBinaryOperation: BooleanBinaryOperation,
  not: Not,
  uInt64AugmentedAssignment: UInt64AugmentedAssignment,
  bigUIntAugmentedAssignment: BigUIntAugmentedAssignment,
  bytesAugmentedAssignment: BytesAugmentedAssignment,
  enumeration: Enumeration,
  reversed: Reversed,
  forInLoop: ForInLoop,
  stateGet: StateGet,
  stateGetEx: StateGetEx,
  stateExists: StateExists,
  stateDelete: StateDelete,
  newStruct: NewStruct,
  subroutineArgument: SubroutineArgument,
  methodDocumentation: MethodDocumentation,
  subroutine: Subroutine,
  contractMethod: ContractMethod,
  appStorageDefinition: AppStorageDefinition,
  logicSignature: LogicSignature,
  compiledContract: CompiledContract,
  compiledLogicSig: CompiledLogicSig,
  stateTotals: StateTotals,
  aRC4Router: ARC4Router,
  contractFragment: ContractFragment,
  uInt64Constant: IntegerConstant,
  bigUIntConstant: IntegerConstant,
} as const
export interface ExpressionVisitor<T> {
  visitIntegerConstant(expression: IntegerConstant): T
  visitDecimalConstant(expression: DecimalConstant): T
  visitBoolConstant(expression: BoolConstant): T
  visitBytesConstant(expression: BytesConstant): T
  visitStringConstant(expression: StringConstant): T
  visitVoidConstant(expression: VoidConstant): T
  visitTemplateVar(expression: TemplateVar): T
  visitMethodConstant(expression: MethodConstant): T
  visitAddressConstant(expression: AddressConstant): T
  visitARC4Encode(expression: ARC4Encode): T
  visitCopy(expression: Copy): T
  visitArrayConcat(expression: ArrayConcat): T
  visitArrayPop(expression: ArrayPop): T
  visitArrayExtend(expression: ArrayExtend): T
  visitARC4Decode(expression: ARC4Decode): T
  visitIntrinsicCall(expression: IntrinsicCall): T
  visitCreateInnerTransaction(expression: CreateInnerTransaction): T
  visitUpdateInnerTransaction(expression: UpdateInnerTransaction): T
  visitGroupTransactionReference(expression: GroupTransactionReference): T
  visitCheckedMaybe(expression: CheckedMaybe): T
  visitTupleExpression(expression: TupleExpression): T
  visitTupleItemExpression(expression: TupleItemExpression): T
  visitVarExpression(expression: VarExpression): T
  visitInnerTransactionField(expression: InnerTransactionField): T
  visitSubmitInnerTransaction(expression: SubmitInnerTransaction): T
  visitFieldExpression(expression: FieldExpression): T
  visitIndexExpression(expression: IndexExpression): T
  visitSliceExpression(expression: SliceExpression): T
  visitIntersectionSliceExpression(expression: IntersectionSliceExpression): T
  visitAppStateExpression(expression: AppStateExpression): T
  visitAppAccountStateExpression(expression: AppAccountStateExpression): T
  visitBoxValueExpression(expression: BoxValueExpression): T
  visitSingleEvaluation(expression: SingleEvaluation): T
  visitReinterpretCast(expression: ReinterpretCast): T
  visitNewArray(expression: NewArray): T
  visitConditionalExpression(expression: ConditionalExpression): T
  visitAssignmentExpression(expression: AssignmentExpression): T
  visitNumericComparisonExpression(expression: NumericComparisonExpression): T
  visitBytesComparisonExpression(expression: BytesComparisonExpression): T
  visitSubroutineCallExpression(expression: SubroutineCallExpression): T
  visitPuyaLibCall(expression: PuyaLibCall): T
  visitUInt64UnaryOperation(expression: UInt64UnaryOperation): T
  visitUInt64PostfixUnaryOperation(expression: UInt64PostfixUnaryOperation): T
  visitBigUIntPostfixUnaryOperation(expression: BigUIntPostfixUnaryOperation): T
  visitBytesUnaryOperation(expression: BytesUnaryOperation): T
  visitUInt64BinaryOperation(expression: UInt64BinaryOperation): T
  visitBigUIntBinaryOperation(expression: BigUIntBinaryOperation): T
  visitBytesBinaryOperation(expression: BytesBinaryOperation): T
  visitBooleanBinaryOperation(expression: BooleanBinaryOperation): T
  visitNot(expression: Not): T
  visitEnumeration(expression: Enumeration): T
  visitReversed(expression: Reversed): T
  visitStateGet(expression: StateGet): T
  visitStateGetEx(expression: StateGetEx): T
  visitStateExists(expression: StateExists): T
  visitStateDelete(expression: StateDelete): T
  visitNewStruct(expression: NewStruct): T
  visitCompiledContract(expression: CompiledContract): T
  visitCompiledLogicSig(expression: CompiledLogicSig): T
  visitARC4Router(expression: ARC4Router): T
}
export interface StatementVisitor<T> {
  visitExpressionStatement(statement: ExpressionStatement): T
  visitBlock(statement: Block): T
  visitGoto(statement: Goto): T
  visitIfElse(statement: IfElse): T
  visitSwitch(statement: Switch): T
  visitWhileLoop(statement: WhileLoop): T
  visitLoopExit(statement: LoopExit): T
  visitLoopContinue(statement: LoopContinue): T
  visitReturnStatement(statement: ReturnStatement): T
  visitAssignmentStatement(statement: AssignmentStatement): T
  visitUInt64AugmentedAssignment(statement: UInt64AugmentedAssignment): T
  visitBigUIntAugmentedAssignment(statement: BigUIntAugmentedAssignment): T
  visitBytesAugmentedAssignment(statement: BytesAugmentedAssignment): T
  visitForInLoop(statement: ForInLoop): T
}
export interface ContractMemberNodeVisitor<T> {
  visitContractMethod(contractMemberNode: ContractMethod): T
  visitAppStorageDefinition(contractMemberNode: AppStorageDefinition): T
}
export interface RootNodeVisitor<T> {
  visitSubroutine(rootNode: Subroutine): T
  visitLogicSignature(rootNode: LogicSignature): T
  visitContractFragment(rootNode: ContractFragment): T
}
